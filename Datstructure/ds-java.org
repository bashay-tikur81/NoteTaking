#+TITLE: Data Structures and Algorithm in Java 6th Edition
#+AUTHOR_OF_TEXTBOOK: Micheal T. Goodrich, Roberto Tamassia, Micheal H.Goldwasser
#+AUTHOR: Ertale81

* Object-Oriented Design
** Goals, Principles and Patterns
*** Object-Oriented Design Goals
- The main "actors" in object-oriented paradigm are called *objects*. Each object is an instance of a class. Each class presents to the outside world a concise and consistent view of the object that are instances of this class.
- The class definition typically specifies that *data fields*, also known as *instance variables*, that an object contains, as well as the *methods* (operations) that an object can execute.
- Software implementation should achieve *robustness, adaptability*, and *reusability*
  1) We want a software to be *robust*, that is, capable of handling unexpected inputs that are not explicitly defined for its application.
  2) Software needs to be able evolve overtime in response to changing condition in its environment. This is called *adaptability* (also called *evolvability*). Related to this concept is *portability*, which is the ability of a software to run with minimal changes on different hardware and operating system platforms. An advantage of writing software in Java is its portability.
     1) Going hand in hand with adaptability is the desire that software be reusable, that is, the same code should be usable as a component of different systems in various applications.
*** Object-Oriented Design Principles
- Chief among the principles of the object-oriented approach, which are intended to facilitate the goals outlined above are:
  + Abstraction: The notion of *abstraction* is to distill a complicated system down into its most fundamental parts. Typically, describing the parts of a system involves naming them and explaining their functionality.
  + Encapsulation: Different components of a software system should not reveal the internal details their respective implementations. One of the main advantages of encapsulation is that it gives one programmer freedom to implement the details of a component, without concern that other programmers will be writing code that intricately depends on those internal decisions. The only constraint on the programmer of a component is to maintain the public interface for the component, as other programmers will be writing code that depends on that interface. Encapsulation yields robustness and adaptability, for it allows the implementation details of parts of a program to change without adversely affecting other parts, thereby making it easier to fix bugs or add new functionality with relatively local changes to a component.
  + Modularity: This refers to different components of a software system are divided into separate functional units. Robustness is greatly increased because it is easier to test and debug separate components before they are integrated into a larger software system.
- Difference between abstraction and encapsulation:

  |--------------------------------------------+-------------------------------------------|
  | Abstraction                                | Encapsulation                             |
  |--------------------------------------------+-------------------------------------------|
  | - Solves the problem at design level.      | - Solves its implementation level.        |
  |--------------------------------------------+-------------------------------------------|
  | - Hides unwanted details while giving out  | - Hiding the code and data into a single  |
  | most essential details.                    | unit to protect the inner working of an   |
  |                                            | object from outside world.                |
  |--------------------------------------------+-------------------------------------------|
  | - Lets you focus on what the object does   | - It hides the internal detail how the    |
  | instead of how it does                     | object works                              |
  |--------------------------------------------+-------------------------------------------|
  | - It focuses on outer lookouts.e.g, moving | - It focuses on internal working or inner |
  | of a vehicle                               | lookout.e.g, how exactly the vehicle move |
  |--------------------------------------------+-------------------------------------------|
  | - In Java Abstraction is supported using   | - In Java encapsulation is supported      |
  | /interfaces and abstract classes/            | using access modifiers. e.g, /public,/      |
  |                                            | /private and /protected/                     |
  |--------------------------------------------+-------------------------------------------|
*** Design Patterns
- Design patterns describes a solution to a "typical" software design problem. A pattern provides a general template for a solution that can be applied in many different situations. It describes the main elements of a solution in an abstract way that can be specialized for a specific problem at hand.
- These design patterns fall into two groups:
  1) Pattern for solving algorithm design problems. For example:
     + Recursion
     + Amortization
     + Divide-and-conquer
     + Prune-and-search, also known as decrease-and-conquer
     + Brute force
     + Greedy method
     + Dynamic programming
  2) Patterns for solving software engineering problems. For example:
     + Template method
     + Composition
     + Adapter
     + Position
     + Iterator
     + Factory
     + Comparator
     + Locator
** Inheritance
*** What is Inheritance
- Inheritance is a mechanism for a modular and hierarchical organization. This allows a new class to be defined based upon an existing class as the starting point. We say that a subclass(child class) *extends* a superclass(parent or base class).
- When inheritance is used, the subclass automatically inherits, as its starting point, all methods from the superclass (other than constructors). The subclass can differentiate itself from its superclass in two ways.
  1) It may *augment* the superclass by adding new fields and new methods.
  2) It may also *specialize* existing behaviors by providing a new implementation that overrides an existing method.
*** Polymorphism
- In the context of object-oriented design, polymorphism  refers to the ability of a reference variable to take different forms.
- *Liskov Substitution Principle*, states that a variable (or a parameter) with a declared type can be assigned an instance from any direct or indirect subclass of that type. Informally, this is a manifestation of the "is a" relationship modeled by inheritance.
- When we say a variable is *polymorphic*, it can take one of many forms, depending of the specific class of the object to which it refers.
- Java uses a process known as *dynamic dispatch*, deciding at runtime to call the version of the method that is most specific to the actual type of the referenced object(not the declared type). Let's assume we have a superclass "Human" and a subclass "Student" and both classes have a method called walk. And we have a variable declared as Human but the referenced object is Student. So, when we call walk method the method inside Student class will get executed. This is Java's dynamic dispatch. But for this to work both the superclass and subclass must have both method name.
- Java also provides an *instanceof* operator that tests, at runtime, whether an instance satisfies as a particular type.
** Interface and Abstract Class
*** Interface
- The main structural element in Java that enforces an API is *interface*. An interface is a collection of method declarations with no data and with no bodies. That is the methods of an interface are always empty; they are simply method signatures. Interface do not have constructors and they cannot be directly instantiated.
- When a class implements an interface, it must implement all of the methods declared in the interface. In this way, interfaces enforce requirements that an implementing class has methods with certain specified signatures.
- In Java, multiple inheritance is allowed for interface but not for classes. The reason for this rule is that interfaces do not define fields or method bodies, yet classes typically do. Thus, if Java were to allow multiple inheritance for classes, there could be a confusion if a class tried to extend from two classes that contained fields with the same name or methods with the same signatures. Since there is no such confusion for interfaces, and there are times when multiple inheritance of interfaces is useful, Java allows interfaces to use multiple inheritance.
*** Abstract Classes
- In Java, an *abstract class* serves a role somewhat between that of a traditional class and that of an interface. Like an interface, an abstract class may define signatures for one or more methods without providing an implementation of those method bodies; such methods are known as *abstract methods*. However, unlike an interface, an abstract class may define one or more fields and any number of methods with implementation (so-called *concrete methods*). An abstract class may also extend another class and be extended by further subclasses.
- As is the case with interfaces, an abstract class may not be instantiated, that is, no object can be created directly from an abstract class. In a sense, it remains an incomplete class. A subclass of an abstract class must provide an implementation for the abstract methods of its superclass, or else remain abstract. To distinguish from abstract classes, we will refer to nonabstract classes as *concrete classes*.
- In comparing the use of interfaces and abstract classes, it is clear that abstract classes are more powerful, as they can provide some concrete functionality. However, the use of abstract classes in Java is limited to *single inheritance*, so a class may have at most one superclass, whether concrete or abstract.
** Exceptions
- Exceptions are unexpected events that occur during the execution of a program. An exception might result due to an unavailable resource, unexpected input from user, or simply a logical error on part of the programmer. In Java, exceptions are objects that can be *thrown* by code that encounters an unexpected situation, or by the Java Virtual Machine, for example, if running out of memory. An exception may also *caught* by a surrounding block of code that "handles" the problem in an appropriate fashion. If uncaught, an exception causes the virtual machine to stop executing the program and to report an appropriate message to the console.
- A general methodology for handling exception is a *try-catch* construct in which a guarded fragment of code that might throw an exception is executed. If it throws an exception, then that exception is *caught* by having the flow of control jump to a predefined *catch* block that contains the code to analyze the exception and apply an appropriate resolution. If no exception occurs in the guarded code, all catch blocks are ignored.
*** Throwing Exception
- Exceptions originate when a piece of Java code finds some sort of problem during execution and *throws* an exception object. This is done by using the *throw* keyword followed by an instance of the exception type to be thrown. It is often convenient to instantiate an exception object at the time the execution has to be thrown. Thus, a *throw* statement is typically written as follows:
      *throw new* /exceptionType(parameters);/
      where exceptionType is the type of the exception and the parameters are sent to that type’s constructor; most exception types offer a version of a constructor that accepts an error message string as a parameter.
- *The Throws Clause*:
  + When a method is declared, it is possible to explicitly declare, as part of its signature, the possibility that a particular exception type may be thrown during a call to that method. It doesn't matter whether the exception is directly from a *throw* statement in that method body, or propagated upward from a secondary method call made from within the body.
  + The syntax for declaring possible exceptions in a method signature relies on the keyword *throws* (not to be confused with an actual throw statement).
- *Checked and Unchecked Exception*
  + Java provides further refinement by declaring the /RuntimeException class/ as an important subclass of Exception. All subtypes of /RuntimeException/ in Java are officially treated as *unchecked exceptions*, and any exception type that is not part of the RuntimeException is a *checked exception*.
  + The intent of the design is that runtime exceptions occur entirely due to mistakes in programming logic, such as using a bad index with an array, or sending an inappropriate value as a parameter to a method. While such programming errors will certainly occur as part of the software development process, they should presumably be resolved before software reaches production quality. Therefore, it is not in the interest of efficiency to explicitly check for such mistake at runtime, and thus are designated as *"unchecked"* exceptions.
  + In contrast, other exceptions occur because of conditions that cannot easily be detected until a program is executing, such as an unavailable file or a failed network connection. Those are typically designated as “checked” exceptions in Java (and thus, not a subtype of RuntimeException).
  + The designation between checked and unchecked exceptions plays a significant role in the syntax of the language. In particular, *all checked exceptions that might propagate upward from a method must be explicitly declared in its signature.*
  + A consequence is that if one method calls a second method declaring checked exceptions, then the call to that second method must either be guarded within a try-catch statement, or else the calling method must itself declare the checked exceptions in its signature, since there is risk that such an exception might propagate upward from the calling method.
** Casting and Generics
*** Casting
- *A widening conversion* occurs when a type /T/ is converted into a "wider" type /U/. The following are common cases of widening conversion:
  + /T/ and /U/ are class types and /U/ is superclass of /T/.
  + /T/ and /U/ are interface types and /U/ is a superinterface of /T/.
  + /T/ is a class that implements interface /U/.
- Widening conversions are automatically performed to store the result of an expression into a variable, without the need for an explicit cast. Thus, we can directly assign the result of an expression of type /T/ into a variable v of type /U/ when the conversion from /T/ to /U/ is a widening conversion.
- The correctness of a widening conversion can be checked by the compiler and its validity does not require testing by the Java runtime environment during program execution.
- *A narrowing conversion* occurs when a type /T/ is converted to a "narrower" type /S/. The following are common cases of narrowing conversions:
  + /T/ and /S/ are class types and /S/ is subclass of /T/.
  + /T/ and /S/ are interface types and /S/ is subinterface of /T/.
  + /T/ is an interface implemented by a class /S/.
- In general, a narrowing conversion of reference types requires an explicit cast. Also, the correctness of a narrowing conversion may not be verifiable by the compiler. Thus, its validity should be tested by the Java runtime environment during program execution.
- *Casting Exceptions*
  + In Java, we can cast an object reference /o/ of type /T/ into a type /S/, provided the object /o/ is referring to is actually type /S/. If, on the other hand, object /o/ is not also type /S/, then attempting to cast /o/ to type /S/ will throw an exception called *ClassCastException*.
  + To avoid problems such as this and to avoid peppering our code with try-catch block every time we perform a cast, Java provides a way to make sure an object cast be correct. Namely, it provides an operator, *instanceof*, that allows us to test whether an object variable is referring to an object that belongs a particular type. The syntax for this operator is /objectReference/ *instanceof* /referenceType/, where /objectReference/ is an expression that evaluates to an object reference and /referenceType/ is the name of some existing class, interface, or enum. If /objectReference/ is indeed an instance satisfying /referenceType/, then the operator returns *true*; otherwise it returns *false*. Thus, we can avoid a /ClassCastException/ from being thrown in this way.
*** Generics
- Java includes support for writing *generic* classes and methods that can operate on a variety of data types while often avoiding the need for explicit cast. The generics framework allows us to define a class in terms of a set of *formal type parameters*, which can then be used as the declared type for variables, parameters, and return values within the class definition. Those formal type parameters are later specified when using the generic class as a type elsewhere in the program.
- When subsequently declaring a variable with such a parameterize type, we must explicitly specify *actual type parameter* that will take the place of the generic formal type parameter. The actual types for generic programming must be object types, so use wrapper classes for primitive types. Like:
      Pair<String, Double> pr;
      Here, we are using *Double* wrapper class not *double* primitive type.
- There is an important caveat related to generic types and the use of arrays. Although Java allows the declaration of an array storing a parameterized type, it doesn't technically allow the  instantiation of a new array involving those types. Fortunately, it allows an array defined with parameterized type to be initialized with a newly created, non parametric array, which can then be cast to the parameterized type. Even so, this later mechanism causes the Java compiler to issue warning, because it isn't 100% type-safe.
- Assume that we want to create a generic /Portfolio/ class that can store a fixed number of generic entries in an array. If the class uses <T> as a parameterized type, it can declare an array of type T[], but it can not directly instantiate such an array. Instead, a common approach is to instantiate an array of type Object[], and then make narrowing cast to type T[], as shown in the following:
  
  #+BEGIN_SRC java
    public class Portfolio<T>{
        T[] data;
        public Portfolio(int capacity){
            data = new T[capacity]; // illegal, compiler error
            data = (T[]) new Object[capacity]; // legal, but compiler warning
        }
    }
  #+END_SRC
- *Generic Methods*
  + The generic framework allows us to define generic version of individual methods(as opposed to generic version of entire class). To do so, we include a generic formal type declaration among the method modifiers.
         /public static <T> void reverse(T[] data);/
         Here, the use of <T> modifier used to declare the method to be generic.
         But this generic method can not be applied to primitive arrays, because autoboxing doesn't apply to entire arrays.
- *Bounded Generic Types*
  + By default, when using a type name such as T in a generic class or method, a user can specify any object type as the actual type of the generic. A formal parameter type can be restricted by using the *extends* keyword followed by a class or interface. In that case, only a type that satifies the stated condition is allowed to substitute for the parameter. The advantage of such a bounded type is that it becomes possible to call any methods that are guaranted by the stated bound.
  + As an example, we might declare a generic ShoppingCart that could only be instantiated with a type that satisfied the Sellable interface. Such class would be declared beginning with the line:
        *public class* ShoppingCart<T *extends* Sellable>{}
        Within this class definition, we would then be allowed to call methods found on Sellable such as description() and lowestPrice() on any instances of type T
** Nested Classes
- Java allows a class definition to be *nested* inside the definition of another class. The main use for nesting classes is when defining a class that is strongly affiliated with another class. This can help increase encapsulation and reduce undesired name conflicts. Nested classes are a valuable technique when implementing data structures, as an instance a nested use can be used to represent a small portion of a larger data structure, or an auxiliary class that helps navigate a primary data structure.
- The containing class is known as the *outer class*. The *nested class* is formally a member of the outer class, and its fully qualified name is /OuterName.NestedName/.
- The use of nested classes can help reduce name collisions, as it is perfectly acceptable to have another class named /NestedClassName/ nested within some other class(or as a self-standing class).
- A nested class has an independent set of modifiers from the outer class. Visibility modifiers (e.g., *public, private*) effect whether the nested class definition is accessible beyond the outer class definition. For example, a private nested class can be used by the outer class, but by no other classes.
- A nested class can also be designated as either *static* or (by default) *nonstatic*, with significant consequences. A *static* nested class is most like a traditional class; its instances have no association with any specific instance of the outer class.
- A nonstatic nested class is more commonly known as an *inner class* in Java. An instance of an inner class can only be created from within a nonstatic method of the outer class, and that inner instance becomes associated with the outer instance that creates it. Each instance of an inner class implicitly stores a reference to its associated outer instance, accessible from within the inner class method using the syntax *OuterName.this* (as opposed to *this*, which refers to the inner instance). The inner instance also has private access to all members of its associated outer instance, and can rely on the formal type parameters of the outer class, if generic.
* Fundamental Data Structures
** Arrays
- We use a variable to represent the array as a whole. Example of declaring an array variable:
      int[] grades;
      [] indicates that it will represent an array
      the /int/ indicates that the elements will be ints.
- Declaring an array variable doesn't create the array. Example of creating an array:
      grades = new int[8];
- We often declare and create an array in the same statement. General syntax is:
      /type[] arrayName = new type[length];/
- Length of an array can be obtained as: arrayName.length. Note that, it is not a method.
- When you create an array but not give a value, the runtime system give the elements a default value. The value used depend on the type of the elements:
  |---------+---------------|
  | type    | default value |
  |---------+---------------|
  | int     | 0             |
  |---------+---------------|
  | double  | 0.0           |
  |---------+---------------|
  | char    | '\0'          |
  |---------+---------------|
  | boolean | false         |
  |---------+---------------|
  | Object  | null          |
  |---------+---------------|
- If a variable represents an object, the object itself is not stored inside the variable. Rather, the object is located somewhere else in memory, and the variable holds the memory address of that object. A variable that stores a reference to an object are called /reference variable./
- An array is a type of object. Thus, an array variable is a reference variable, it stores a reference to an array.
- When we assign the value of one reference variable to another, we copy the reference to the object. We don't copy the object itself.
- Once we have created an array, we can not increase its size. Instead, we need to do the following:
  + create a new, larger array(use a temporary variable)
  + copy the contents of the original array into the new array
  + assign the new array to the original array variable
- We can also create a multi-dimensional arrays. The most common type is a two-dimensional (2-D) array. We can visualize it as a matrix consisting of rows and columns.
  For example:
      int[][] scores = new int[5][8];
- To access an element, we use an expression of the form /arrayName[row][column]/
  e.g., scores[2][1];
- 2-D array can be used for maintaining a game board, like Tic-Tac-Toe
- A 2-D array is really an array of arrays. For example:
      int[][] scores = new int[5][8];
      in this array creation, scores[0] represents the entire first row; scores[1] represents the entire second row, etc...
- arrayName.length gives the number of rows. /arrayName[row].length/ gives the number of columns in that row.
- To perform some operations on all the elements in a 2-D array, we typically uses a nested loop.
- It is also possible to have a "ragged" 2-D array in which different rows have different number of columns.
      int[][] foo = {{11,22,33},{7,20,30,40}, {1,2}};
** Linked-List
- A linked list is a collection of *nodes* that collectively for a linear sequence. In a singly linked list, each node stores a reference to an object that is an element of the sequence, as well as a reference to the next node of the list.
- A linked list's representation relies on the collaboration of many objects. Minimally, the linked list instance must keep a reference to the first node of the list, known as a *head*. Without an explicit reference to the head, there would be no way to locate that node (or indirectly, any others).
- The last node of the list is known as the *tail*. The tail of a list can be found by traversing the linked list— starting at the head and moving from one node to another by following each node’s next reference. We can identify the tail as the node having *null* as its next reference. This process is also known as *link hopping* or *pointer hopping*. However, storing an explicit reference to the tail node is a common efficiency to avoid such a traversal.
- It is common for a linked list instance to keep a count of the total number of nodes that comprise the list (also known as the *size* of the list), to avoid traversing the list to count the nodes.
*** Implementing A Singly Linked List Class
- The SinglyLinkedList class supports the following methods:
  + size(): returns the number of elements in the list
  + isEmpty(): returns *true* if the list is empty, and *false* otherwise
  + first(): returns(but doesn't remove) the first element in the list
  + last(): returns(but doesn't remove) the last element in the list
  + addFirst(e): add a new element to the front of the list
  + addLast(e): add a new element to the last of the list
  + removeFirst(): removes and returns the first element of the list
*** Circularly Linked List
- Linked lists are traditionally viewed as storing a sequence of items in a linear order, from first to last. However, there are many applications in which data can be more naturally viewed as having a *cyclic order*, with well-defined neighboring relationships, but no fixed beginning or end.
- For example, many multiplayer games are turn-based, with player A taking a turn, then player B, then player C, and so on, but eventually back to player A again, and player B again, with the pattern repeating. As another example, city buses and subways often run on a continuous loop, making stops in a scheduled order, but with no designated first or last stop.
- Circularly Linked List is essentially a singularly linked list in which the /next/ reference of the tail node is set to refer back to the head of the list(rather than *null*).
- This new CircularLinkedList class supports all the public behaviors of SinglyLinkedList class and one additional update method:
      *rotate()*: moves the first element to the end of the list.
- In implementing a CircularLinkedList class, we make one additional optimization—we no longer explicitly maintain the head reference. So long as we maintain a reference to the tail, we can locate the head as *tail.getNext()*. Maintaining only the tail reference not only saves a bit on memory usage, it makes the code simpler and more efficient, as it removes the need to perform additional operations to keep a head reference current.
- Implementing the new *rotate* method is quite trivial. We do not move any nodes or elements, we simply advance the tail reference to  point to the node that follows it(the implicit head of the list).
- We can add a new element at the front of the list by creating a new node and linking it just after the tail of the list. To implement the *addLast* method, we can rely on the use of a call to *addFirst* and then immediately advance the tail reference so that the newest node becomes the last.
*** Doubly Linked Lists
- In a singly linked list, each node maintains a reference to the next node that is immediately after it. This representation is useful for managing sequence of elements. However, there are limitations that stem from the asymmetry of a singly linked list.
- We can efficiently insert a node at either end of a singly linked list, and can delete a node at the head of a list, but we are unable to efficiently delete a node at the tail of the list. More generally, we cannot efficiently delete an arbitrary node from an interior position of the list if only given a reference to that node, because we cannot determine the node that immediately /precedes/ the node to be deleted (yet, that node needs to have its next reference updated).
- To provide greater symmetry, we define a linked list in which each node keeps an explicit reference to the node before it and a reference to the node after it. Such a structure is known as a *doubly linked list*. These lists allow a greater variety of *O(1)-time update operations*, including insertions and deletions at arbitrary positions within the list.
**** *Header and Trailer Sentinels*
+ In order to avoid some special cases when operating near the boundaries of a doubly linked list, it helps to add special nodes at both ends of the list: a *header node* at the beginning of the list, and a *trailer node* at the end of the list. These “dummy” nodes are known as *sentinels (or guards)* (sentinel -- a person employed to keep watch for some anticipated event), and they do not store elements of the primary sequence.
+ When using sentinel nodes, an empty list is initialized so that the /next/ field of the /header/ points to the /trailer/, and the /prev/ of the /trailer/ points to the /header/; the remaining fields of the sentinels are irrelevant(presumably /null/ in Java).
+ For a nonempty list, the header’s next will refer to a node containing the first real element of a sequence, just as the trailer’s prev references the node containing the last element of a sequence.
+ Although we could implement doubly linked list without sentinel nodes, the slight extra memory devoted to the sentinels greatly simplifies the logic of our operation. Most notably, the header and trailer nodes never change—only the nodes between them change. Furthermore, we can treat all insertions in a unified manner, because a new node will always be placed between a pair of existing nodes. In similar fashion, every element that is to be deleted is guaranteed to be stored in a node that has neighbors on each side.
+ Every insertion into our doubly linked list representation will take place between a pair of existing nodes.
+ The deletion of a node proceeds in the opposite fashion of insertion. The two neighbors of the node to be deleted are linked directly to each other, thereby bypassing the original node. As a result, that node will no longer be considered part of the list and it can be reclaimed by the system. Because of our use of sentinels, the same implementation can be used when deleting the first or the last element of a sequence, because even such an element will be stored at a node that lies between two others.
*** Implementing a Doubly Linked List Class
- Doubly Linked List class should support the following public methods:
  + size(): returns the number of elements in the list.
  + isEmpty(): returns *true* if the list is empty, and *false* otherwise.
  + first(): returns(but doesn't remove) the first element in the list.
  + last(): returns(but doesn't remove) the last element in the list.
  + addFirst(e): add a new element to the front of the list.
  + addLast(e): add a new element to the last of the list.
  + removeFirst(): removes and returns the first element of the list.
  + removeLast(): removes and returns the last element of the list.
- If first( ), last( ), removeFirst( ), or removeLast( ) are called on a list that is empty, we will return a *null* reference and leave the list unchanged.
** Equivalence Testing
- When working with reference types, there are many different notions of what it means for one expression to be equal to another. At the lowest level, if a and b are reference variables, then expression *a == b* tests whether a and b refer to the same object (or if both are set to the *null* value).
- However, for many types there is a higher-level notion of two variables being considered “equivalent” even if they do not actually refer to the same instance of the class. For example, we typically want to consider two String instances to be equivalent to each other if they represent the identical sequence of characters.
- To support a broader notion of equivalence, all object types support a method named equals. Users of reference types should rely on the syntax a.equals(b), unless they have a specific need to test the more narrow notion of identity. The equals method is formally defined in the Object class, which serves as a superclass for all reference types, but that implementation reverts to returning the value of expression a == b. Defining a more meaningful notion of equivalence requires knowledge about a class and its representation.
- The author of each class has a responsibility to provide an implementation of the equals method, which overrides the one inherited from Object, if there is a more relevant definition for the equivalence of two instances. For example, Java’s String class redefines equals to test character-for-character equivalence.
- Great care must be taken when overriding the notion of equality, as the consistency of Java’s libraries depends upon the equals method defining what is known /as an *equivalence relation* in mathematics/, satisfying the following properties:
  + *Treatment of null:* For any nonnull reference variable x, the call x.equals(*null*) should return *false* (that is, nothing equals *null* except null).
  + *Reflexivity:* For any nonnull reference variable x, the call x.equals(x) should return *true* (that is, an object should equal itself).
  + *Symmetry:* For any nonnull reference variables x and y, the calls x.equals(y) and y.equals(x) should return the same value.
  + *Transitivity:* For any nonnull reference variables x, y, and z, if both calls     x.equals(y) and y.equals(z) return *true*, then call x.equals(z) must return *true* as well.
*** Equivalence Testing with Arrays
*** Equivalence Testing with Linked Lists
** Cloning Data Structure
- The beauty of object-oriented programming is that abstraction allows for a data structure to be treated as a single object, even though the encapsulated implementation of the structure might rely on a more complex combination of many objects.
- In a programming environment, a common expectation is that a copy of an object has its own state and that, once made, the copy is independent of the original(so, changes to one do not affect the other). However, when objects have fields that are reference variable pointing to auxiliary object, it is not always obvious whether a copy should have a corresponding field that refers to the same auxiliary object, or to a new copy of that auxiliary object.
- Each class in Java is responsible for defining whether its instances can be copied, and if so, precisely how the copy is constructed. The universal *Object* superclass defined a method named *clone*, which can be used to produce what is known as /a *shallow copy* of/ an object. This uses the standard assignment semantics to assign the value of each field of the new object equal to the corresponding field of the existing object that is being copied. The reason this is known as a shallow copy is because if the field is a reference type, then an initialization of the form duplicate.field = original.field causes the field of the new object to refer to the same underlying instance as the field of the original object. A shallow copy is not always appropriate for all classes, and therefore, Java intentionally disables use of /the *clone() method* by/ declaring it as *protected*, and by having it throw a /CloneNotSupportedException/ when called. The author of a class must explicitly declare support for cloning by formally declaring that the class implements the Cloneable interface, and by declaring a public version of the *clone()* method. That public method can simply call the protected one to do the field-by-field assignment that results in a shallow copy, if appropriate. However, for many classes, the class may choose to implement a deeper version of cloning, in which some of the referenced objects are themselves cloned.
*** Cloning Arrays
+ Consider the following code:
      int[] data = {2,3,5,7,11,13,17,19};
      int[] backup;
      backup = data;
      The assignment of variable /backup/ to data doesn't create any new array; it simply creates a new alias for the same array.
+ Instead, if we want to make a copy of the array, data, and assign a reference to the new array to variable, backup, we should write:
      backup = data.clone();
      The clone method, when executed on an array, initializes each cell of the new array to the value that is stored in the corresponding cell of the original array. This results in an independent array.
      If we subsequently make an assignment such as data[4] = 23 in this configuration, the backup array is unaffected.
+ There are more considerations when copying an array that stores reference type rather than primitive types. The clone() method produces a *shallow copy* of an array, producing a new array whose cells refer to the same objects referenced by the first array. A *deep copy* of a list can be created by iteratively cloning the individual elements. But to use *clone()* method to copy every item, the class must be declared as /Cloneable/.
+ Because a two-dimensional array is really a one-dimensional array storing other one-dimensional arrays, the same distinction between a shallow and deep copy exists. Unfortunately, the java.util.Arrays class does not provide any *“deepClone”* method. However, we can implement our own method by cloning the individual rows of an array.
*** Cloning Linked Lists
+ The first step to making a class cloneable in Java is declaring that it implements /Cloneable/ interface. First line of class definition looks like the ff:
      public class SinglyLinkedList<E> implements Cloneable{}
      The remaining task is implementing a public version of clone() method of the class.
* Stacks, Queues, and Deques
** Stacks
- A *stack* is a collection of objects that are inserted and removed according to /the *last-in, first-out (LIFO)* principle/. A user may insert objects into a stack at any time, but may only access or remove the most recently inserted object that remains (at the so-called “top” of the stack). The name “stack” is derived from the metaphor of a stack of plates.
- The fundamental operations involved are *pushing* and *popping* of plates off the stack.
- Applications of stack:
  1) Internet web browsers store the address of recently visited sites on a stack. Each time a user visits a new site, that site’s address is “pushed” onto the stack of addresses. The browser then allows the user to “pop” back to previously visited sites using the “back” button.
  2) Text editors usually provide an “undo” mechanism that cancels recent editing operations and reverts to former states of a document. This undo operation can be accomplished by keeping text changes in a stack.
  3) Recursive function calls. Stacks are used to manage function calls and local variables. Each time a function is called, its local variables and the return address are pushed onto the stack.
  4) Backtracking algorithm. In algorithms that require backtracking, such as solving mazes or puzzles, stacks are used to keep track of the previous steps.
  5) Expression Evaluation and Conversion. Infix to postfix/prefix conversion.
  6) Syntax parsing.
*** Stack ADT
- Formally, a stack is an abstract data type(ADT) that supports the following two update methods:
  + push(e): Add element /e/ to the top of the stack
  + pop(): Removes and returns the top element from the stack(or null if the stack is empty)
  Additionally, a stack supports the following accessor methods for convenience.
  + top(): Returns the top element of the stack with out removing it(or /null/ if empty).
  + size(): Returns the number of elements in the stack
  + isEmpty(): Returns a boolean indicating whether the stack is empty.
- By convention, we assume that elements added to the stack can have arbitrary type and that a newly
  created stack is empty.
**** A stack Interface in Java
+ We define *application program interface(API)* in the form of a Java *interface*, which describes the names of the methods that the ADT supports and how they are to be declared and used.
+ Interface serves as a type definition but it can not directly instantiated. For the ADT to be of any use, we must provide one or more concrete classes that implement the methods of the interface associated with that ADT.
**** The Adapter Pattern
+ The *adapter* design pattern applies when you want to modify an existing class so that its method match those of related, but different class or interface. One general way to apply the adapter pattern is to define a new class in such a way that it contains an instance of the existing class as a hidden field, and then to implement each method of the new class using methods of this hidden instance variable.
**** Application of Stack
+ Reversing an Array using a Stack.
  As a sequence of LIFO protocol, a stack can be used as a general toll to reverse a data sequence.
+ Matching parentheses and HTML Tags.
  An algorithm for matching delimiters. Each time we encounter an opening symbol, we push that symbol onto the stack, and each time we encounter a closing symbol, we pop symbol from the stack(assuming it's not empty) and check that these two symbols form a valid pair. If we reach the end of the expression and the stack is empty, then the original expression was properly matched. Otherwise, there must be an opening delimiter on the stack without a matching symbol. If the length of the original expression is /n/, the algorithm will make at most /n/ calls to push and /n/ calls to pop.

** Queue
- Queue is a collection of objects that that are inserted and removed according to the *first-in, first-out (FIFO)* principle. That is, elements can be inserted at any time, but only elements that has been in the queue the longest can be next removed. We usually say elements enter a queue at the back and are removed from the front. A queue would be a logical choice for a data structure to handle calls to a customer service center, or a wait-list at a restaurant. FIFO queues are also used by many computing devices, such as a networked printer, or a Web server responding to requests.
*** Queue ADT
+ The queue ADT defines a collection that keeps objects in a sequence, where element access and deletion are restricted to the first element in the queue, and element insertion is restricted to the back of the sequence. This restriction enforces the rule that items are inserted and deleted according to the first-in first-out principle.
+ The queue ADT supports the following two update methods:
      /enqueue(e)/: Add element e to the back of a queue
      /dequeue()/: Removes and returns the first element from the queue(or /null/ if the queue is empty)
+ The queue ADT also supports includes the following accessor methods(with /first/ being analogous to the stack's /top/ method)
      first(): Returns the first element of the queue, without removing it(or /null/ if empty)
      size(): Returns the number of elements in the queue
      isEmpty(): Returns a boolean indicating whether the queue is empty.
+ Java provides a type of queue interface, java.util.Queue, which has functionality similar to the traditional queue ADT, given above, but the documentation for the java.util.Queue interface does not insist that it support only the FIFO principle. When supporting the FIFO principle, the methods of the java.util.Queue interface have the equivalences with the queue ADT.
+ The java.util.Queue interface supports two styles for most operations, which vary in the way that they treat exceptional cases. When a queue is empty, the remove() and element() methods throw a *NoSuchElementException*, while the corresponding methods poll() and peek() return null. For implementations with a bounded capacity, the add method will throw an *IllegalStateException* when full, while the offer method ignores the new element and returns false to signal that the element was not accepted.
**cd** Circular Queue
- A circular queue is an excellent abstraction for applications in which elements are cyclically arranged, such as for multiplayer, turn-based games, or round-robin scheduling of computing processes. In the remainder of this section, we provide a demonstration of the use of a circular queue.
** Double Ended Queue(Deque)
- This is a queue like data structure that supports insertion and deletion at both the front and back of the queue. Such a structure is called a *double-ended queue*, or *deque*, which is usually pronounced “deck” to avoid confusion with the dequeue method of the regular queue ADT, which is pronounced like the abbreviation “D.Q.”
- The deque abstract data type is more general than both the stack and the queue ADTs. The extra generality can be useful in some applications. For example, we described a restaurant using a queue to maintain a waitlist. Occasionally, the first person might be removed from the queue only to find that a table was not available; typically, the restaurant will reinsert the person at the first position in the queue. It may also be that a customer at the end of the queue may grow impatient and leave the restaurant.
- The deque abstract data type is richer than both the stack and the queue ADTs. To provide a symmetrical abstraction, the deque ADT is defined to support the following update methods:
      addFirst(e): Insert a new element /e/ at the front of the deque
      addLast(e): Insert a new element /e/ at the end of the deque
      removeFirst(): Remove and return the first element of deque(or /null/ if the deque is empty)
      removeLast(): Remove and return the last element of the deque(or /null/ if the deque is empty)
- Additionally, the deque ADT will include the following accessors:
      first(): Return the first element of deque without removing it(or /null/ if the deque is empty)
      last(): Return the last element of deque without removing it(or /null/ if the deque is empty)
      size(): Return the number of elements in the deque
      isEmpty(): Return a boolean indicating whether the deque is empty
- We can implement the deque ADT efficiently using either an array or a linked list for storing elements.
* List and Iterator ADTs
**  The List ADT
- In this chapter, we explore several abstract data types that represent a linear sequence of elements, but with more general support for adding or removing elements at arbitrary positions.
- Java defines a general interface, /java.util.List/, that include the following index based methods and more:
      size(): Returns the number of elements in the list
      isEmpty():Returns a boolean whether the list is empty
      get(/i/): Returns the element of the list having index /i/; an error condition occurs if /i/ is
              not in the range [0, size()-1].
      set(/i,e/): Replaces the element at index /i/, with /e/, and returns the old element that was
                replaced; an error condition occurs if /i/ is not in range [0, size()-1]
      add(/i,e/): Insert a new element /e/ in to the list so that it has index /i/, moving all
                subsequent elements one index later in the list; an error condition occurs if /i/ is not in range [0,size()]
      remove(/i/):Removes and returns the element at index /i/, moving all subsequent elements one
                index earlier in the list; an error condition occurs if /i/ is not in the range [0, size()-1].
- *We note that the index of an existing element may change over time, as other elements are added or removed in front of it. We also draw attention to the fact that the range of valid indices for the add method includes the current size of the list, in which case the new element becomes the last.*
- 
** Array List
- An obvious choice for implementing the list ADT is to use array A, where *A[i]* stores (a reference) the element with index /i/. With a representation on an array A, the get(/i/), and set(/i,e/) methods are easy to implement by accessing A[i] (assuming /i/ is a legitimate index). Methods add(/i,e/) and remove(/i/) are more time consuming, as they require shifting elements up or down to maintain our rule of always storing element whose list index is /i/ at index /i/ of the array. 
** Dynamic Array
- The ArrayList Implementation as well as those for stack, queue, deque, has a serious limitation; it requires that a fixed maximum capacity be declared, throwing an exception if attempting to add an element once full. This is a major weakness, because if a user is unsure of the maximum size that will be reached for a collection, there is risk that either too large of an array will be requested, causing an inefficient waste of memory, or that too small of an array will be requested, causing a fatal error when exhausting that capacity.
- Java's ArrayList class provides a more robust abstraction, allowing a user to add elements to the list, with no apparent limit on the overall capacity. To provide this abstraction Java relies on a *dynamic array*.
- In reality, element of an ArrayList are stored in a traditional array, and the precise size of that traditional array must be internally declared in order for the system to properly allocate a consecutive piece of memory for its storage.
- Because the system may allocate neighboring memory locations to store other data, the capacity of an array cannot be increased by expanding into subsequent cells.
- The first key to providing the semantics of an unbounded array is that an array list instance maintains an internal array that often has greater capacity than the current length of the list. For example, while a user may have created a list with five elements, the system may have reserved an underlying array capable of storing eight object references (rather than only five). This extra capacity makes it easy to add a new element to the end of the list by using the next available cell of the array.
- If a user continues to add elements to a list, all reserved capacity in the underlying array will eventually be exhausted. In that case, the class requests a new, larger array from the system, and copies all references from the smaller array into the beginning of the new array. At that point in time, the old array is no longer needed, so it can be reclaimed by the system.
- A commonly used rule is for the new array to have twice the capacity of the existing array that has been filled.
*** Java's StringBuilder Class
+ The StringBuilder class represents a mutable string by storing characters in a dynamic array.
** Positional List
- When working with array-based sequences, integer indices provide an excellent means for describing the location of an element, or the location at which an insertion or deletion should take place. However, numeric indices are not a good choice for describing positions within a linked list because, knowing only an element’s index, the only way to reach it is to traverse the list incrementally from its beginning or end, counting elements along the way.
- Indices are not a good abstraction for describing a more local view of a position in a sequence, because the index of an entry changes over time due to insertions and deletions that happen on the sequence earlier. For example, it may not be convenient to describe the location of a person waiting in line based on the index, as that requires knowledge of precisely how far away that person is from the front of the line. We prefer an abstraction, in which there is some other means for describing a position.
- Our goal is to design an abstract data type that provides a user a way to refer to elements anywhere in a sequence, and to perform arbitrarily insertions and deletions. This would allow us to efficiently describe actions such as a person deciding to leave the line before reaching the front, or allowing a friend to “cut” into line right behind him or her.
- As another example, a text document can be viewed as a long sequence of characters. A word processor uses the abstraction of a *cursor* to describe a position within the document without explicit use of an integer index, allowing operations such as “delete the character at the cursor” or “insert a new character just after the cursor.” Furthermore, we may be able to refer to an inherent position within a document, such as the beginning of a particular chapter, without relying on a character index (or even a chapter number) that may change as the document evolves.
- For those reasons we develop our own abstract data type that we denote as a *positional list*. Although a positional list is an abstraction, and need not rely on a linked list for its implementation, we certainly have a linked list in mind as we design the ADT, ensuring that it takes best advantage of particular capabilities of a linked list, such as /O(1)/-time insertions and deletions at arbitrary positions(something that is not possible with an array-based sequence).
- We face an immediate challenge in designing the ADT; to achieve constant time insertions and deletions at arbitrary locations, we effectively need a reference to the node at which an element is stored.

*** Positions
- To provide a general abstraction for the location of an element within a structure, we define a simple *position* abstract data type. A position supports the following single method:
      getElement(): Returns the element stored at this position
- A positions acts as a marker or token within a broader positional list. A position /p/, which is associated with some element /e/ in a list /L/, does not change, even if the index of /e/ changes in /L/ due to insertions or deletions elsewhere in the list. Nor does position of /p/ changes if we replace the element /e/ stored at /p/ with another element. The only way in which a position becomes invalid is if that position (its element) are explicitly removed from the list.
- Having a formal definition of a position type allows positions to serve as parameters to some methods and return values from other methods of the positional list ADT.
- We now view a *positional list* as a collection of positions, each of which store an element. The accessor methods provided by the positional list ADT includes the following for a list *L*:
  + first(): Returns the position of the first element of /L/ (or null if empty)
  + last(): Returns the position of the last element of /L/ (or null if empty)
  + before(p): Returns the position of /L/ immediately before position /p/ (or null if /p/ is the first position)
  + after(p): Returns the position of /L/ immediately after position /p/ (or null if /p/ is the last position)
  + isEmpty(): Returns /true/ if list /L/ doesn't contain any elements
  + size(): Returns the number of elements in list /L/.
- An error occurs if a position /p/, sent as a parameter to a method, is not a valid position for the list.
- Note well that the *first() and last()* methods of the positional list ADT return the associated positions, not the elements. (This is in contrast to the corresponding first and last methods of the deque ADT.) The first element of a positional list can be determined by subsequently invoking the getElement method on that position, as *first().getElement*. The advantage of receiving a position as a return value is that we can subsequently use that position to traverse the list.
- The positional list ADT also includes the following *update* methods:
  + addFirst(e): Inserts a new element /e/ at the front of the list, returning the position of the new element.
  + addLast(e): Inserts a new element /e/ at the end of the list, returning the position of the new element.
  + addBefore(p,e): Inserts a new element /e/ in the list, just before position /p/, returning the position of the new element.
  + addAfter(p,e): Inserts a new element /e/ in the list, just after position /p/, returning the position of the new element.
  + set(p,e): Replaces the element at position /p/ with element /e/, returning the element formerly at position /p/.
  + remove(p): Removes and returns the element at position /p/ in the list, invalidating the position.
  
** Iterator
- An iterator pattern is a design pattern in which an iterator is used to traverse a container and access the container's elements. The iterator pattern decouples the algorithm from the container; in some cases algorithms are container-specific and can't decoupled.
- An iterator is a software design pattern that abstracts the process of scanning through a sequence of elements, one element at a time. The underlying elements may be stored at in a container class, streaming through a network, or generated by a series of computations.
- In order to unify the treatment and syntax for iterating objects in a way that is independent from a specific organization, java defines the /java.util.Iterator/ interface with the following two methods:
  1) hasNext(): returns true if there is at least one additional element in the sequence, false otherwise.
  2) next(): Returns the next element in the sequence
- The /java.util.Iterator/ interface contains a third method, which is /optionally/ supported by some iterators:
  1) remove(): Removes from the collection the element returned by the most recent call to next(). Throws an IllegalStateException if next has not yet been called, or if remove was already called since the most recent call to next().
     This method can be used to filter a collection of elements, for example to discard all negative numbers from a data set.
** The Java Collection framework
- Java provides many data structure interfaces and classes, which together form the *Java Collections Framework*.
- The root interface in the Java collections framework is named *Collection*. This is a general interface for any data structure.
- The collection interface is the superinterface for other interfaces in the Java collections framework that can hold elements, including the /java.util/ interfaces *Deque, List, Set, Map, Queue...*
- The Java Collections Framework also includes concrete classes implementing various interfaces with a combination of properties and underlying representations.
