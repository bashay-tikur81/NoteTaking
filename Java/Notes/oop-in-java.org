#+TITLE: Learning OOP using Java
#+AUTHOR: Ertale81
#+STARTDATE: <2024-10-17 Thu>
#+BOOK: Schildt H. Complete Java Reference(2022) 12 edtion

* Closer look at Classes and Methods
** Class Fundamentals
- Class is the logical construct upon which the entire Java language is built because it defines the shape and nature of an object.
- The most important thing to understand about a class is that it defines a new /data type/. Once defined, this new type can be used to create objects of that type. Thus, a class is a /template/ for an object, and an object is an /instance/ of a class. Note that, a class declaration only creates a template; it doesn't create an actual object.
- Each time you create an instance of a class, you are creating an object that contains its own copy of each instance variable and methods defined by the class.
- Dot operator(.) links the name of the object with the name of an instance variable and methods. Generally dot operator uses to access both the instance variables and methods defined within an object.
- A /constructor/ initializes an object immediately upon creation. It has same name as the class in which it resides and is syntactically similar to a method. Once defined the constructor is automatically called when the object is created, before the *new* operator completes. Constructors look a little strange because they have no return type, even *void*. This is because the implicit return type of a class' constructor is the class type itself. It's the constructor's job to initialize the internal state of an object so that the code creating an instance will have a fully initialized, usable object immediately.
- When using a default constructor, all non-initialized instance variables will have their default values, which are zero, *null, false* for numeric types, reference types and boolean respectively.
- Once you define your own constructor, the default constructor is no longer used.
- Sometimes a method will need to refer to the object that invoked it. To allow this, Java defines the *this* keyword. *this* can be used inside any method to refer to the /current/ object. That is, *this* is always a reference to the object on which the method was invoked.
  *this* will always refer to the invoking object.
*** Garbage collection
- Since objects are dynamically allocated by using the *new* operator, how such objects are destroyed and their memory released for later reallocation? Java uses a technique called /garbage collection/ that handles deallocation automatically for you. It works like this: /when no reference to an object exists, that object is assumed no longer needed, and the memory occupied by the object can be reclaimed/. There is no need to explicitly destroy objects.
** Method Overloading
- In Java, it is possible to define two or more methods within the same class that share same name, as long as their parameter declarations are different. When this is the case the methods are said to be overloaded, and the process is referred to as /method overloading/. Thus overloaded methods must differ in the type and/or number of their parameters. While overloaded may have different return types, the return type alone is insufficient to distinguish two versions of the method. When Java encounters a call to an overloaded method, it simply executes the version of the method whose parameters match the arguments used in the call. When an overloaded method is called, Java looks for a match between the arguments used to call the method and the method's parameters. However, this match need not always be exact. In some cases, Java's automatic type conversion can play a role in overloaded resolution. But Java will employ its automatic type conversions only if no exact match is found. Method overloading supports polymorphism.
** Using Objects as Parameters
- It is common and norm to pass objects to methods.
- One of the most common uses of object parameters involves constructors. Frequently, you will want to construct a new object so that it's initially the same as some existing object.
** Closer look at Argument Passing
- In general, there are two ways that a computer language can pass an argument to subroutine.
  1) /call-by-value/ - copies the /value/ of an argument into the formal parameter of subroutine. Therefore, changes made to the parameter of subroutine has no effect on the argument.
  2) /call-by-reference/ - a reference to an argument(not the value of the argument) is passed to the parameter. Inside subroutine, this reference is used to access the actual argument specified in the call. This means that changes made to the parameter will affect the argument used to call the subroutine.
- Although Java uses /call-by-value/ to pass all arguments, the precise effect differs between whether a primitive type or a reference type is passed.
- When you pass a primitive type to a method, is passed by value. However, when you pass an object to a method, the object argument is passed as /call-by-reference/.
- /Remember when an object reference is passed to a method, the reference itself is passed by use of call-by-value, since the value being passed refers to an object, the copy of that value will still refer to the same object that its corresponding argument does/.
** Returning an Object
- A method can return any type of data, including class types that you create.
** Access Control
- Java's access modifier are *public, private, and protected*. Java also defines a default access control. *protected* applies only when inheritance is involved.
- when a member of a class is modified by *public*, then that member can be accessed by any other code. When a member of class is specified as *private*, then that member can only be accessed by other members of its class.
- The *main()* method is always preceded by the *public* modifier because it's called by code that is outside the program -- that is, by the Java run-time system. When no access modifier is used, they by default the member of a class is public within its own package, but can not be accessed outside its package. When members are declared using *private*, since you can't access them from another class, you are gonna use /getters and setters/ to get and set the values respectively.
- An access modifier precedes the rest of a member's type specification. That is it must begin a member's declaration statement.
** Understanding Static
- There will be times when you will want to define a class member that will be used independently of any object of that class. Normally, a class member must be accessed only in conjunction with an object of its class. However, it's possible to create a member that an be used by itself, without reference to a specific instance. To create such member, precede its declaration with the keyword *static*. When an member is declared *static*, /it can be accessed before any objects of its class are created, and without reference to any object./ You can declare both methods and variables to be *static*. The most common example of static member is *main()*. *main()* is declared as *static* because it must be called before any object exist. Instance variables declared as *static* are, essentially, global variables. When objects of its class are declared, no copy of a *static* variable is made. Instead all the instances of the class share the same *static* variable.
- Methods declared as *static* have several restrictions:
  + They can only directly call other *static* methods of their class
  + They can only directly access *static* variables of their class
  + They cannot refer to *this* or *super* in any way.
- If you need to do computation in order to initialize your *static* variables, you can declare a *static* block that gets executed exactly once, when the class is first loaded. As soon as the /className/ class is loaded, all of the static statements are run.
- Outside of the class in which they are defined, *static* methods and variables can be used independently of any object. To do so, you need only specify the name of their class followed by the dot operator. For example, if you wish to call a *static* method outside its class, you can do so using the following general form:
      /ClassName.method()/
      Here /ClassName/ is the name of the class in which the static method is declared.
** Introducing Final
- A field can be declared as final. Doing so prevents its contents from being modified, making it essentially, a constant. This means that you must initialize a *final* field when it's declared. You can do this in one of two ways: First, you can give it a value when its declared. Second, you can assign it a value within a constructor. The first approach is probably the most common.
  e.g:
      /final int FILE_OPEN = 1;/
- It's common coding convention to choose all uppercase identifiers for final fields.
- Both method parameters and local variables can be declared *final*.
  Declaring a parameter *final* prevents it from being changed within the method. Declaring a local variable *final* prevents it from being assigned a value more than once.
- The keyword *final* can also be applied to methods, but its meaning is substantially different than when it is applied to variables.
** Introducing Nested and Inner Classes
- It is possible to define a class within another class; such classes are known as /nested classes/. The scope of a nested class is bounded by the scope of its enclosing class. Thus, if class B is defined within class A, then B doesn't exist independently of A. A nested class has access to the members, including private members, of the class in which it is nested. However, the enclosing class does not have access to the member of the nested class. A nested class that is declared directly within its enclosing class scope is a member of its enclosing class. It's also possible to declare a nested class that is local to a block.
- There are two types of nested classes:
  1) /static/ nested class- a /static/ nested class is one that has the *static* modifier applied. Because it's *static* it must access the non-static members of its enclosing class through an object. That is, it can not refer to non-static members of its enclosing class directly.
  2) /inner class/ - it's a non-static nested class. It has access to all of the variables and methods of its outer class and may refer to them directly in the same way that other non-static members of the outer class do.
- *Note*: An instance of a inner class can be created only in the context of the enclosing class. The Java compiler generates an error otherwise. In general, an inner class instance is often created by code within its enclosing scope.
- An inner class has access to all of the members of its enclosing class, but the reverse is not true.
- In addition to declaring an inner class as a members within an outer class scope, we can define inner class within any block scope. For example, you can define a nested class within the block defined by a method or even within a body of *for* loop.
- Anonymous inner class - inner class that don't have name??
** String Class
- *String* is probably the most commonly used class in Java's class library.
- The first thing to understand about strings is that every string you create is actually an object of type *String*. Even string constants are actually *String* objects. For example:
  #+begin_src java
    System.out.println("This is a String, too");
  #+end_src
  The string "This is a String, too" is a *String* object.
- The second thing to understand about strings is that object of type *String* are /immutable/; once a *String* object is created, its content cannot be altered. While this may seem like a serious restriction, it is not, for two reasons:
  1) If you need to change a string, you can always create a new one that contains the modification
  2) Java defines peer classes of *String*, called *StringBuffer* and *StringBuilder*, which allow string to be altered, so all of the normal string manipulations are still available in Java.
- Java defines one operator for *String* objects: *+*. It is used to concatenate two strings.
- The *String* class contains several methods that you can use. Some are:
  + /boolean equals(secondStr);/
  + /int lenght();/
  + /char charAt(index);/
- Of course, you can have array of strings, just like you can have arrays of any other type of object.
** Using Command Line Arguments
- Sometimes you will want to pass information into a program when you run it. This is accomplished by passing /command-line arguments/ to *main()*. A command-line argument is the information that directly follows the program's name on the command-line  when it is executed. In Java those command-line arguments are stored as strings in a *String* array passed to the args parameter of *main()*.
  The first is at args[0], second at args[1] ...
- *Remember*: All command-line arguments are passed as strings. You must convert values to their internal forms manually.
** Varargs: Variable Length Arguments
- This allows methods to take variable number of arguments. e.g: printf() method
- In the early days of Java varargs could be handled in two ways, neither of which are particularly pleasing.
  1) If the maximum number of arguments was small and known, then you could create overloaded version of the method, one for each way the method could be called. Although this works and is suitable for some cases, it applies to only a narrow class of situations.
  2) If the maximum number of arguments was larger or unknown, the arguments was put into an array, and then the array was passed to the method. This approach requires that these arguments be manually packaged into an array prior to calling the method. Not only it is tedious to construct an array each time the method is called, it's potentially error prone. The varargs feature offers simpler, better option.
- varargs is specified by three dots(...)
  e.g:
       /static void varargsTest(int... v){}/
       This syntax tells the compiler that varargsTest() can be called with zero or more arguments. As a result *v* is implicitly declared as an array of type *int[]*. Thus, inside *varargsTest(), v* is accessed using the normal array index.
       The *...* syntax simply tells the compiler a variable number of arguments will be used, and that these arguments will be stored in the array referred to by *v*.
- A method can have "normal" parameters along with variable length parameters. However, the variable-length parameter must be the last parameter declared by the method.
  For example:
      /int doInt(int a, int b, double c, int ... vals){}/
      /Remember, the varargs parameter must be last/.
- There is one more restriction to be aware of: there must be only one varargs parameter.
  For example, this declaration is invalid.
      /int doInt(int a, int b, double c, int ... vals, double ... morevals){}/
- You can overload varargs methods. One way to overload is by differing types of the parameters. The second way to overload a varargs method is to add one or more normal parameters. In this case, Java uses both the number of arguments and type of the arguments to determine which method to call.
- *Note*: A varargs method can also be overloaded by a non-varargs method. For example, doInt(int x) is a valid overload of doInt() in the above example. This method is invoked only when one *int* argument is present. When two ore more *int* arguments are passed, the varargs version doInt(int a, int b, double c int ... vals) is used.
- *varargs and ambiguity*
  - It's perfectly fine to overload varargs with arguments having different data types. But if they all accept zero or more arguments and the caller passes with zero argument the compiler gets confused to choose which method to call since all the varargs accept zero number of argument. Not only this one but even with having normal parameters.
    e.g:
        /static void vaTest(int ... v){}/
        /static void vaTest(int n, int ... v) {}/
        There is no way the compiler resolve the following call:
        /vaTest(1);/
        These situations are ambiguous.
** Local Variable Type Inference with Reference types.
- Beginning with JDK 10, Java supports local variable type inference. When using local variable type inference, the type of the variable is specified as *var* and the variable must be initialized. Type inference can be used with primitive types and with reference types. In fact, type inference with reference types constitutes a primary use.
  For exampe:
      /var myStr = "This is a string";/
      Because a quoted string is used as an initializer, the type *String* is infered
- One of the benefits of local variable type inference is its ability to streamline code, and it's with reference types where such streamlining is most apparent. The reason for this is that many class types in Java have rather long names. For example, let's see the *FileInputStream* class, which is used to open a file for input operation. In the past, you would declare and initialize a *FileInputStream* using a traditional declaration like shown below:
      /FileInputStream fin = new FileInputStream("test.txt");/
      with the use of var it can now be writtne:
      /var fin = new FileInputStream("test.txt");
      Here, *fin* is inferred to be type *FileInputStream* because that is the type of its initializer. There is no need to explicitly repeat the type name. As a result, this declaration of *fin* is shorter than writing in traditional way. Thus, the use of *var* streamlines the declaration.
- In general, the streamlining attribute of local variable type inference helps lessen the tedium of entering long type names into your program.
- The streamlining aspect of local variable type inference must be used carefully to avoid reducing the readability of your program and, thus, obscuring its meaning.
- You can also use local variable type inference with user-defined classes.
  e.g:
      /var udc = new UserDefinedClass();/
* Inheritance
** Inheritance Basic
- In the terminology of Java, a class that is inherited is called a /superclass/ and the class that does the inheriting is called /subclass/. Therefore, a subclass is a specialized version of a superclass. It inherits all of the members defined by the superclass and adds its own, unique elements.
- To inherit a class, you simply incorporate the definition of one class into another by using the *extends* keyword. You can only specify one superclass for any subclass that you create. Java doesn't support the inheritance of multiple superclasses into a single subclass. You can create a hierarchy  of inheritance in which a subclass becomes a superclass of another subclass. However, no class can be a superclass of itself.
- Although a subclass includes all of the members of its superclass, it can not access those members of superclass that have been declared as *private*
- *Remember* A class member that has been declared as private will remain private to its class. It's not accessible by any code outside its class, including subclass.
- A major advantage of inheritance is that once you have created a superclass that defines the attributes common to set of objects, it can be used to create any number of more specific subclasses.
** A Superclass Variable Can Reference a Subclass Object
- A reference variable of a superclass can be assigned a reference to any subclass derived from that superclass. You will find this aspect of inheritance quite useful in a variety of situations.
- It is important to understand that it is the *type the reference variable* -- not the *type of the object that it refers to* -- that determines what members can be accessed. That is, when a reference to a subclass object is assigned to a superclass reference variable, you will have access only to those parts of the object defined by the superclass.(because the reference is variable is superclass reference variable). This makes sense because the superclass has no knowledge of the subclass.
** Using Super
*** First use of super
- There will be times when you will want to create a superclass that keeps the details of its implementation to itself(that is, that keeps its data members private). In this case, there will be no way for a subclass to directly access or initialize these variables on its own. Since encapsulation is the primary attribute of OOP, Java also provides a solution to this problem. Whenever a subclass needs to refer to its immediate superclass, it can do so by use of the keyword *super*.
- *super* has two general forms. The first calls the superclass' constructor. The second is used to access a member of the superclass that has been hidden by a member of subclass.
*** Using super to call superclass constructor
- A subclass can call a constructor defined by its superclass by use of the following form of *super*:
      /super(arg-list);/
      Here, /arg-list/ specifies any arguments needed by the constructor in the superclass. *super()* must always be the first statement executed inside a subclass' constructor.
- Since constructors can be overloaded, *super()* can be called using any form defined by the superclass. The constructor executed will be the one that matches the argument.
- *Remember*: a superclass variable can be used to reference any object derived from that class.
*** A Second use for super
- The second form of *super* acts somewhat like *this*, except that it always refers to the superclass of the subclass in which it's used.
      /super.member;/
      Here member can be either a method or instance variable.
- This form of *super* is most applicable to situations in which member names of a subclass hide members by the same name in the superclass.
  e.g:
      /int i;/
      /i = 9;/ this will refer variable in subclass
      /super.i = 9;/ this will refer variable in superclass.
      *super* allows access to methods and variables defined in the superclass.
*** When Constructors are executed in inheritance hierarchy
- In class hierarchy, constructors complete their execution in order of derivation, from superclass to subclass. Further, since *super()* must be the first element executed in a subclass' constructor, this order is the same whether or not *super()* is used. If *super()* is not used then the default or parameterless constructor of each superclass will be executed.
*** Method Overriding
- In class hierarchy, when a method in a subclass has the same name and type signature as the method in superclass, then the method in the subclass is said to /override/ the method in the superclass. When an overridden method is called through its subclass, it will always refer to the version of that method defined by the subclass. The version of the method defined by the superclass will be hidden.
- If you wish to access the superclass version of an overridden method, you can do so by using *super*.
- Method overriding occurs /only/ when the names and the type signature of two methods are identical. If they are not the two methods are simply overloaded.
** Dynamic Method Dispatch
- Method overriding forms the basis for one of Java's most powerful concepts: /dynamic method dispatch/. Dynamic method dispatch is the mechanism by which a call to an overridden method is resolved at runtime, rather than compile time. Dynamic method dispatch is important because this is how Java implements /run-time polymorphism/
- Java uses a principle, a superclass reference variable can refer to a subclass object, to resolve calls to overridden methods at run-time. Here is how. When an overridden method is called through superclass reference, Java determines which version of that method to execute based up on the type of object being referred to at the time the call occurs. Thus, this determination is made at run-time. When different types of objects are referred to, different version of an overridden method will be called. In other words, /it's the type of the object being referred to/ (not the type of reference variable) that determines which version of an overridden method will be executed. Therefore, if a superclass contains a method that is overridden by a subclass, then when different types objects are referred to through a superclass reference variable, different versions of the method are executed.
** Why Overridden methods?
- Overridden methods allow Java to support run-time polymorphism. Polymorphism is essential for one reason: it allows a general class to specify methods that will be common to all of its derivatives, while allowing subclasses to define the specific implementation of some or all of those methods.
- Overridden methods are another way that Java implements the "one interface, multiple methods" aspect of polymorphism.
- By combining inheritance with overridden methods, a superclass can define the general form of the methods that will be used by all its subclasses.
** Using Abstract Classes
- Abstract class is a class that declares the structure of a given abstraction without providing a complete implementation of every method. That is, you will create a superclass that only defines a generalized format that will be shared by all of its subclasses, leaving it to each subclass to fill in details.
- To make sure that the class methods are overridden is to make the method /abstract/.
- To declare an abstract method, use the general form:
      /abstract type name(parameter-list);/
      As you can see no method body is present.
- Any class that contains one or more abstract method must also be declared abstract. To declare a class abstract, you simply use the *abstract* keyword in front of the *class* keyword at the beginning of the class declaration.
- There can be no objects of an abstract class. That is, an abstract class can not be directly instantiated with the *new* operator.
- Concrete methods are still allowed in abstract classes.
- Although it's not possible to create an object of type *abstract class*, you can create a reference variable of type *abstract class*. And that reference variable can be used to refer to an object of any class derived from the *abstract class*. It's through superclass reference variable that overridden methods are resolved at run-time.
** Using final with inheritance
- To disallow methods from being overridden, specify *final* as a modifier at the start of its declaration. Methods declared as *final* can not be overridden.
- Methods declared as *final* can sometimes provide a performance enhancement: The compiler is free to /inline/ calls to them because it "knows" they will not be overridden by subclasses. When a small *final* method is called, often the Java compiler can copy the bytecode for the subroutine directly inline with the compiled code of the calling method, thus eliminates the costly overhead associated with the method call. Inlining is an option only with *final* methods. Normally Java resolves calls to methods dynamically, at run time. This is called /late binding/. However, since *final* methods cannot be overridden, a call to one can be resolved at compile time. This is called /early binding./
- If you want to prevent a class from being inherited, precede the class declaration with *final*. Declaring a class as *final* implicitly declares all of its methods as *final* too.
- It's illegal to declare a class as both *abstract* and *final* since an abstract class is incomplete by itself and relies upon its subclasses to provide complete implementation.

** The Object Class
- There is one special class, *Object*, defined by Java, where all other classes are subclasses of *Object* class. That is *Object* is the superclass of all other classes. This means that a reference variable of type *Object* can refer to all object of any other class. Also since arrays are implemented as classes, a variable type *Object* can also refer to any array.
- *Object* define the following methods, which means that they are available to every object.
  |------------------------------|
  | Object clone()               |
  |------------------------------|
  | boolean equals(Object obj)   |
  |------------------------------|
  | void finalize()              |
  |------------------------------|
  | Class <?>getClass()          |
  |------------------------------|
  | int hasCode()                |
  |------------------------------|
  | void notify()                |
  |------------------------------|
  | void notifyAll()             |
  |------------------------------|
  | String toString()            |
  |------------------------------|
  | void wait()                  |
  | void wait(long milliseconds) |
  | void wait(long milliseconds, |
  | long nanoseconds)            |
  |------------------------------|
- The methods *getClass(), notify(), notifyAll(), and wait()* are declared as *final*. You may override the others. However, notice two methods for now:
  *equals(Object obj)* and *toString()*. The equals() method compares two objects and the toString() method returns a string that contains a description of the object in which it is called. Also, the method is automatically called when an object is output using println().

* Packages and Interfaces
** Packages
- Packages are containers for classes. They are used to keep the class name space compartmentalized. The package is both naming and visibility control mechanism. You can define classes inside a package that are not accessible by code outside the package. You can also define a class members that are exposed only to other members of the same package. This allows your classes to have intimate knowledge of each other, but not expose that knowledge to the rest of the world.
- The general form of the *package* statement:
      /package pkg;/
- Typically, Java uses file system directories to store packages. The *package* statement simply specifies to which package the classes defined in a file belong. It doesn't exclude other classes in other files from being part of that same package.
- You can create a hierarchy of packages. To do so, simply separate each package name from the one above it by use of period.
      /package pkg[.pkg1][.pkg2];/
      /package a.b.c;/
- 
** Finding Packages and CLASSPATH
- How does the Java run-time systems know where to look for packages that you create?
  The answer has three parts:
  1) By default, the Java run-time system uses the current working directory as its starting point. Thus, if your package is in a subdirectory of the current directory, it will be found.
  2) You can specify a directory path or paths by selecting the *CLASSPATH* environment variable.
  3) You can use the *-classpath* option with the *java* and *javac* to specify the path to your classes.
- /package mypack;/
  In order for a program to find *mypack*, the program can be executed from a directory immediately above *mypack,* or the *CLASSPATH* must be set to include the path to *mypack*, or the *-classpath* option must specify the path to *mypack* when the program is run with *java*.
- Classes and packages are both means of encapsulating and containing the name space and scope of variables and methods. Packages act as containers for classes and other subordinate packages. Classes act as containers for data and code. The class is Java's smallest unit of abstraction.
- Java's access control mechanism:
  + public - can be accessed from different classes and different packages
  + private - cannot be accessed outside of its class
  + default(no explicit access specification) - it is visible to subclasses as well as other classes in the same package.
  + protected - can be seen outside your current package, but only to classes that subclass your class directly
- The above applies only to members of class. A non-nested class has only two possible access levels: *default and public*. When a class is *public*, it's accessible outside its package. If a class has default access, then it can only be accessed by other code within its same package. /When a class is public, it must be the only public class declared in the file, and the file must have same as the class./
** Importing Packages
- Java includes the *import* statement to bring certain classes, or entire packages, into visibility. Once imported, a class can be referred to directly, using only its name.
- In Java source file, *import* statements occur immediately following the package statements(if exists) and before any class definition.
- General form of the *import* statement:
      /import pkg1.[.pkg2].(classname |*);/
      e.g:
      /import java.util.Date;/ // explicit class name
      /import java.io.*;/ // import entire package, packages below java.io
** Interfaces
*** What is interface
- Using the keyword *interface*, you can fully abstract class' interface from its implementation.
- Interface uses to specify what a class must do, but not how it does. Interfaces are syntactically similar to classes, but they lack instance variables, and, as a general rule, their methods are declared without any body. Also, one class can implement any number of interfaces.
- To implement an interface, a class must provide a complete set of methods required by the interface. However, each class is free to determine the details of its implementation.
- By providing the *interface* keyword, Java allows you to fully utilize the "one interface, multiple methods" aspect of polymorphism.
- Interface are designed to support dynamic method resolution at run time. Normally, in order for a method to be called from one class to another, both class needed to be present at compile time so the Java compiler can check to ensure that the method signature are compatible. This requirement by itself makes for a static and nonextensible classing environment. Inevitably in a system like this, functionality gets pushed up higher and higher in the class hierarchy so that the mechanisms will be available to more and more subclasses. Interface are designed to avoid this problem. They disconnect the definition of a method or set of methods from the inheritance hierarchy. Since interface are in different hierarchy from classes, it is possible for classes that are unrelated in terms of class hierarchy to implement the same interface. This is where the real power of interface are realized.
- An interface is defined much like class. General form of an interface.
  
      /access interface name {}/
      When no access modifier is used, then default access is used and the interface is only available to other members of the package in which it is declared. When it's is declared as *public*, the interface can be used by code outside its package. In this case, the interface must be the only public interface declared in the file, and the file must have same name as the interface.
      
- Beginning JDK 8, it is possible to add /default implementation/ to an interface method and also added /static interface methods/. And beginning JDK 9, an interface can include private methods. Thus, it is now possible for *interface* to specify some behaviors.
- As a general rule, you will still often create and use interfaces in which no use is made to those new features.
- Variables that are declared inside interfaces are by implicitly *final* and *static*, meaning they can not be changed by the implementing class. They must also be initialized. All methods and variables are implicitly *public*.
*** Implementing Interface
- Once an interface has been defined, one or more classes can implement that interface.
- To implement an interface, include *implements* clause and the class definition and then create the methods required by the interface. If a class implements more than one interface, the interface are separated with commas(,). If a class implements two interfaces that declare the same method, then the same method will be used by clients of either interface.
- The methods that implement an interface must be declared *public*. Also, the type signature of the implementing method must match exactly the type signature specified in the *interface* definition.
- *Remember* When you implement an interface method, it must be declared as public.
- It is permissible for classes that implement interface to define additional members of their own.
*** Accessing Implementations Through Interface Reference
- You can declare variables as object reference that use an interface rather than a class type. Any instance of any class that implements the declared interface can be referred to by such variable. When you call a method through one of these inferences, the correct version will be called based on the /actual instance of the interface being referred to./ This is one of the key features of an interface. The method to be executed is looked up dynamically at run time, allowing classes to be created later than the code which calls method on them. The calling code can dispatch through an interface without having to know anything about the "callee". This process is similar to using superclass reference to access subclass object.
- *An interface reference variable has knowledge only of the methods declared by its interface declaration.*
*** Partial Implementations
- If a class includes an interface but does not fully implement the methods required by that interface, then that class must be declared as *abstract*.
- If any third(or more) class inherits from another abstract class in which that class itself inherits from another abstract class, the third class(concrete class) must implement all abstract methods from both the parent abstract class and the grandparent abstract class. If the intermediate abstract class has implemented some of the methods, the third class only needs to implement the remaining unimplemented methods. If it does not implement all the abstract class in the parent and grandparent, it must declare itself as abstract.
- 
*** Nested Interface
- An interface can be declared a member of a class or another interface. Such interface is called a /member interface/ or a /nested interface/. A nested interface can be declared as *public, private,* or *protected*. This differs from a top-level interface, which must either be declared as *public* or use default access level. When a nested interface is used outside of its enclosing scope, it must be qualified by the name of the class or interface of which it is a member. Thus, outside of the class or interface in which a nested interface is declared, its name must be fully qualified.
*** Variables in Interface
- You can use interface to import shared constants into multiple classes by simply declaring an interface that contains variables that are initialized to the desired values. When you include that interface in a class(that is when you "implement" the interface), all of these variable names will be in scope as constants. If an interface contains no methods, then any class that includes such an interface doesn't actually implement anything. It's as if that class was importing the constant fields in the class name space as *final* variables.
*** Interface Can Be Extended
- One interface can inherit another by use of the keyword *extends*. The syntax is same as for inheriting classes. *When a class implements an interface that inherits another interface, it must provide implements for all the methods required by the interface inheritance chain.*

*** Default Interface Methods
- The release of JDK 8 adds a new capability to interface called the /default method/. A default method lets you define a default implementation for an interface method. In other words by use of default method, it is possible for an interface method to provide a body, rather than being abstract.
- A primary motivation for the default method was to provide a means by which interfaces can be expanded without breaking existing code. Recall that there must be implementations for all methods defined by an interface. In the past, if a new method was added to a popular, widely used interface, then the addition of that method will break the existing code because no implementation would be found for that method. The default method solves this problem by supplying an implementation that will be used if no other implementation is explicitly provided. Thus, the addition of a default method will not cause preexisting code to break.
- Another motivation for the default methods was the desire to specify methods in an interface that are, essentially, optional, depending on how the interface is used.
- It's important to point out that the addition of default methods does not change a key aspect of *interface*: its inability to maintain state information. All interfaces still can not have instance variables. Thus, the defining difference between an interface and a class is that a class can maintain state information, but an interface can not. Further more, it's still not possible to create an instance of an interface by itself. It must be implemented by a class for an instance variable to be created.
- As a general rule, default methods constitute a special-purpose feature. Interfaces that you create will still be used primarily to specify /what/ and not /how/. However, the inclusion of default methods gives you added flexibility.
- An interface default method is defined similar to the way a methods is defined by a class. The primary difference is that the declaration is preceded by the keyword *default*.
- The default method gives you:
  + a way to gracefully evolve interface over time
  + a way to provide optional functionality without requiring that a class provide a placeholder implementation when that functionality is not needed.

*** Multiple Inheritance Issues
- Assume that two interfaces called *Alpha* and *Beta* are implemented by a class called *MyClass*. What happens if both *Alpha* and *Beta* provide a method called *reset()* for which both declare a default implementation? Or consider situation in which *Beta* extends *Alpha*. Which version of the default method is used? Or, what if *MyClass* provides its own implementation of the method? To handle these situations Java defines a set of rules that resolve such issue.
  1) In all cases, a class implementation takes priority over an interface default implementation. This is the case even if *MyClass* implements both *Alpha* and *Beta*. In this case, both defaults are overridden by *MyClass* implementation.
  2) In cases in which a class implements two interfaces that both have the same default method, but the class doesn't override that method, then an error will result. In cases where one interface inherits another, with both defining a common default method, the inheriting interface's version of the method takes precedence. Therefore, continuing with the example, if *Beta* extends *Alpha*, then *Beta*'s version of *reset()* will be used.
- It's possible to explicitly refer to a default implementation in an inherited interface by using this form of *super*. Its general form is:
      /InterfaceName.super.methodName()/
      For example, if *Beta* wants to refer to *Alpha*'s default *rest()*, it can use this statement:
      /Alpha.super.rest();/
*** Using static Methods in an Interface
- Another capability added to *interface* by JDK 8 is the ability to define one or more *static* methods. Like *static* methods in class, a *static* method defined by an interface can be called independently of any object. Thus, no implementation of the interface is necessary, and no instance of the interface is required, in order to call a *static* method. Instead, a *static* method is called by specifying the interface name, followed by a period, followed by the method name. General form:
      /InterfaceName.staticMethodName();/
      Notice: this is similar to the way that *static* method in a class is called.
*** Private Interface Method
- Beginning with JDK 9, an interface can include a private method. A private interface method can be called only by a default method or another private method by the same interface. Because a private interface method is specified *private*, it cannot be used by code outside the interface in which it's defined. This restriction includes subinterfaces because a private method is not inherited by subinterface.
- The key benefits of a private interface method is that it lets two or more default methods use a common  piece of code, thus avoiding code duplication.
- Private interface method is a feature that you will seldom need.
* Exception Handling
** Exception-Handling Fundamentals
- A Java exception is an object. When an exceptional condition arises, an object representing that exception is created and /thrown/ in the method that caused the error. That method may choose to handle the exception itself, or pass it on. Exceptions can be generated by the Java-runtime system, or they can be manually generated by your code. Exceptions throws by Java relate to fundamental errors that violate the rules of Java language or the constraint of the Java execution environment. Manually generated exceptions are typically used to report some error conditions to the caller of the method.
- Java exception handling is managed via five keywords: *try, catch, throw, throws* and *finally*.
** Exception Types
- All exception types are subclass of built-in class *Throwable*. Thus, *Throwable* is at the top of the exception class hierarchy. Immediately below *Throwable* are two subclasses that partition exception class into two distinct branches.
  1) One branch is headed by *Exception*. This class is used for exceptional conditions that user programs could catch. This is also the class you will subclass to create your own custom exception type. There is an important subclass of *Exception* called *RuntimeException*. Exception of this type are automatically defined for the program that you write
  2) The other branch is toped by *Error*, which defines exceptions that are not expected to be caught under normal circumstances by your program. Exceptions of type *Error* are used by the Java run-time system to indicate errors having to do with the runtime environment, itself. *StackOverFlow* is an example of such Error. These errors can not usually handled by your program
- Any exception that is not caught by your program will ultimately be processed by the default handler. The default handler displays a string describing the exception, prints a stack trace from the point at which the exception occurred, and terminates the program.
- When you handle the exceptions by yourself:
  1) It allows you to fix the error
  2) It prevents the program from automatically terminating
- The goal of most well-constructed *catch* clause should be to resolve the exceptional condition and then continue on as if the error had never happened.
- When you use multiple *catch* statements, it is important to remember that exception subclass muse come before any of their superclass. This is because a *catch* statement that uses a superclass will catch exceptions of that type plus any of its subclass. Thus, a subclass would never be reached if it came after its superclass. Further, in Java, unreachable code is an error.
** throw
- It is possible for your program to throw an exception explicitly, using the *throw* statement. The general form of *throw* is:
      /throw ThrowableInstance;/
      Here, /ThrowableInstance/ must be an object of type of *Throwable* or a subclass of *Throwable*.
- Primitive types such as *int*, or *char* as well as non-*Throwable* classes, such as *String* and *Object*, can not be used as exception. There are two ways you can obtain a *Throwable* object: using a parameter in a *catch* clause or creating one with the *new* operator.
- The flow of execution stops immediately after the *throw* statement; any subsequent statements are not executed. The nearest enclosing *try* block is inspected to see if it has a *catch* statement matches the type of exception. If not, the next enclosing *try* statement is inspected, and so on. If no matching *catch* is found, then the default exception handler halts the program and prints the stack trace.
- Many of Java's built-in run-time exceptions have at least two constructors: one with no parameter and one that takes a string parameter. When the second form is used, the argument specifies a string that describes the exception. This string is displayed when the object is used as an argument to *print()* or *println()*. It can also be obtained by a call to *getMessage()*, which is defined by *Throwable*.
** throws
- If a method is capable of causing an exception that does not handle, it must specify this behavior so that callers of the method can guard themselves against that exception. You do this by including a *throws* clause in the method's declaration. A *throws* clauses lists the type of exceptions that a method might throw. This is necessary for all exceptions, except those of type *Error* or *RuntimeException*, or any of its subclasses. All other exceptions that a method can throw must be declared in the *throws* clause. If they are not, a compile-time error will occur. General form of methods that includes *throws* clause:
      /type method-name(parameter-list) throws exception-list {}/
      Here, /exception-list/ is a comma separated list of exceptions that a method can throw.
** finally
- *finally* creates a block of code that will be executed after *try/catch* block has completed and before the code following the *try/catch* block. The *finally* block will execute whether or not an exception is thrown. If an exception is thrown, the *finally* block will execute even if no *catch* statement matches the exception. Anytime a method is about to return to the caller from inside a *try/catch* block, via uncaught exception or an explicit return statement, the *finally* clause is also executed just before the method returns. This can be useful for closing file handles and freeing up any other resources that might have been allocated at the beginning of a method with the intent of disposing of them before returning. The *finally* clause is optional. However, each *try* statement requires at least one *catch* or a *finally* clause.
** Three Additional Exception Features
- Beginning JDK 7, three interesting and useful features have been part of exception system.
  1) The first automates the process of releasing a resource, when it is no longer needed. It is /try-with-resource/
  2) The second feature is called /multi-catch/ - this allows two or more exceptions to be caught using the same *catch* clause. It is not uncommon for two or more exception handlers to use the same code sequence even though they respond to different exceptions. 
  3) The third is called /final rethrow/ or /more precise rethrow/.
- To use a multi-catch, separate each exception type in the *catch* clause with the OR operator. Each multi-catch parameter is implicitly *final*. (You can explicitly specify *final*, if desired  but not necessary). Because each multi-catch parameter is implicitly *final*, it can't be assigned a new value.
  For example:
      /catch(ArithmeticException | ArrayIndexOutOfBoundsException e){}/

* Multi-threaded Programming
** Multi-threaded
- A multi-threaded program contains two or more parts that can run concurrently. Each part of that such a program is called a /thread/, and each /thread/ defines a separate path of execution. Thus, multi-threading is a specialized form of multi-tasking.
- There are two distinct types of multitasking:
  1) Process-based multitasking
  2) Thread-based multitasking
- Process-based multitasking is the more familiar form. A /process/ is a program that is executing. Thus, /process-based/ multitasking is the feature that allows your computer to run two or more programs concurrently. In process-based multitasking, a program is the smallest unit of code that can be dispatched by the scheduler.
- In a /thread-based/ multitasking environment, the thread is the smallest unit of dispatchable code. This means that a single program can perform two or more tasks simultaneously. For instance, a text editor can format text at the same time that it is printing, as long as these two actions are being performed by two separate threads. Thus, process-based multitasking deals with the “big picture,” and thread-based multitasking handles the details.
- Multitasking threads require less overhead than multitasking process. Process are heavyweight tasks that require their own separate address spaces. Interprocess communication is expensive and limited. Context switching from one process to another process is also costly. Threads on the other hands are lighter weight. They share the same address space and cooperatively share the same heavyweight process. Interthread communication is inexpensive and context switching from one thread to another is lower in cost. While Java programs make use of process-based multitasking environments, process-based multitasking is not under Java’s direct control. However, multithreaded multitasking is.
- Multithreading enables you to write efficient programs that make maximum use of the processing power available in the system. One important way multithreading achieves this is by keeping idle time to minimum. This is especially important for the interactive, networked environment in which Java operates because idle time is common. Multithreading reduces the idle time of the system because another thread can run when one is waiting.
** Java Thread Model
- The Java run-time system depends on threads for many things, and all the class libraries are designed with multithreading in mind. In fact, Java uses threads to enable the entire environment to be asynchronous. This helps reduce inefficient by preventing the waste of CPU cycle.
- The benefits of Java's multithreading is that the main loop/polling mechanism is eliminated. One thread can pause without stopping other parts of your program. For example, the idle time created when a thread reads data from a network or waits for user input can be utilized elsewhere.
- Threads exist in several states.
  + /running/
  + /ready/ -- to run as soon as it gets CPU time
  + /suspended/ -- temporarily halts its activity
  + /resumed/ -- allowing suspended thread to pick up where it left off
  + /blocked/ -- when waiting for resource
  + /terminated/ -- at any time, a thread can be terminated, which halts its execution immediately. Once terminated, a thread can not be resumed.
** Thread priorities
- Java assigns to each thread a priority that determines how that thread should be treated with respect to the others. Thread priorities are integers that specify the relative priority of one thread to another. As an absolute value, a priority is meaningless; a higher-priority thread doesn’t run any faster than a lower-priority thread if it is the only thread running. Instead, a thread's priority is used to decide when to switch from one running thread to the next. This is called /context switch/. The rules that determine when a context switch takes place are simple:
  + /A thread can voluntarily relinquish(relinquish -- release) control./ This occurs when explicitly yielding, sleeping, or when blocked. In this scenario, all other threads are examined, and the highest-priority thread that is ready to run is given the CPU.
  + /A thread can be preempted(preempt -- have precedence over) by a higher-priority thread./ In this case, a lower-priority thread that does not yield the processor is simply preempted --no matter what it is doing-- by a higher-priority thread. Basically, as soon as a higher-priority thread wants to run, it does. This is called /preemptive multitasking/.
- In cases where two threads with the same priority are competing for CPU cycles, the situation is a bit complicated. For some OS, threads of equal priority are time-sliced automatically in round-robin fashion. For other types of OS, threads of equal priority must voluntarily yield control to their peers. If they don't, the other thread won't run.

** Synchronization
- Because multithreading introduces an asynchronous behavior to your programs, there must be a way for you to enforce synchronicity when you need it. For example, if you want two threads to communicate and share a complicated data structure, such as a linked list, you need some way to ensure that they don’t conflict with each other. That is, you must prevent one thread from writing data while another thread is in the middle of reading it. For this purpose, Java implements an elegant twist on an age-old model of interprocess synchronization: the /monitor/. You can think of a monitor as a very small box that can hold only one thread. Once a thread enters a monitor, all other threads must wait until that thread exits the monitor. In this way, a monitor can be used to protect a shared asset from being manipulated by more than one thread at a time.
- In Java, there is no class “Monitor”; instead, each object has its own implicit monitor that is automatically entered when one of the object’s synchronized methods is called. Once a thread is inside a synchronized method, no other thread can call any other synchronized method on the same object. This enables you to write very clear and concise multithreaded code, because synchronization support is built into the language.

** Messaging
- After you divide your program int separate threads, you need to define how they will communicate with each other. When programming with some other languages, you must depend on the operating system to establish communication between threads. This, of course, adds overhead. By contrast, Java provides a clean, low-cost way for two or more threads to talk to each other, via calls to predefined methods that all objects have. Java’s messaging system allows a thread to enter a synchronized method on an object, and then wait there until some other thread explicitly notifies it to come out.

** The Thread Class and The Runnable Interface
- Java’s multithreading system is built upon the *Thread* class, its methods, and its companion interface, *Runnable*. *Thread* encapsulate a thread of execution. Since you can’t directly refer to the ethereal state of a running thread, you will deal with it through its proxy, the *Thread* instance that spawned it.
- To create a new thread, your program will either extend *Thread* or implement the *Runnable* interface.
- The *Thread* class defines several methods that help manage threads. Some of them are:

  |-------------+------------------------------------------|
  | *Method*      | *Meaning*                                  |
  |-------------+------------------------------------------|
  | getName     | Obtain a thread's name                   |
  |-------------+------------------------------------------|
  | getPriority | Obtain a thread's priority               |
  |-------------+------------------------------------------|
  | isAlive     | Determine if a thread is still running   |
  |-------------+------------------------------------------|
  | join        | Wait for a thread to terminate           |
  |-------------+------------------------------------------|
  | run         | Entry point for the thread               |
  |-------------+------------------------------------------|
  | sleep       | suspend a thread for a period of time    |
  |-------------+------------------------------------------|
  | start       | Start a thread by calling its run method |
  |-------------+------------------------------------------|

** The Main Thread
- When a Java program starts up, one thread begins running immediately. This is usually called the /main thread/ of your program, because it is the one that is executed when your program begins. The main thread is important for two reasons:  1) It is the thread from which other "child" threads will be spawned(spawn -- make offspring by reproduction)
  2) Often, it must be the last thread to finish execution because it performs various shutdown actions.
- Although the main thread is created automatically when your program is started, it can be controlled through a *Thread* object. To do so, you must obtain a reference to it by calling the method *currentThread()*, which is a *public static* member of Thread. Its general form is shown here:
      static Thread currentThread()
      This method returns a reference to the thread in which it is called. Once you have a reference to the main thread, you can control it just like any other thread.
** Creating a Thread
- In the most general sense, you create a thread by instantiating an object of type *Thread*. Java defines two ways in which this can be accomplished:
  1) You can implement the *Runnable* interface
  2) You can extend the *Thread* class, itself.
*** Implementing Runnable
- The easiest way to create is to create a class that implements the *Runnable* interface. *Runnable* abstracts a unit of executable code. You can construct a method on any object that implements *Runnable*. To implement *Runnable*, a class need only implement a single method called *run()*, which is described like this:
      public void run()
      Inside *run()*, you will define the code that constitutes the new thread.
- It's important to understand that *run()* can call other methods, user other classes, and declare variables, just like the main method can. The main difference is that *run()* establishes the entry point for another, concurrent thread of execution within your program. This thread will end when *run()* returns.
- After you create a class that implements *Runnable*, you will instantiate an object of type *Thread* from within that class. *Thread* defines several constructors. The one that we will use is:
      Thread(Runnable /threadOb/, String /threadName/)
      In this constructor, /threadOb/ is an instance of a class that implements the *Runnable* interface. This defines where execution of the thread will begin. The name of the new thread is specified by /threadName/.
- After the new thread is created, it will not start running until you call its *start()* method, which is declared within *Thread*. In essence, *start()* initiates a call to *run()*. The *start()* method is shown here:
      void start()
*** Extending Thread
- The second way to create thread is to create a new class that extends *Thread*, then to create an instance of that class. The extending class must override the *run()* method, which is the entry point of the new thread. And call to *start()* begins execution of the new thread.
** Choosing Approach
- Why Java has two ways to create child threads? And which approach is better? The answers to these questions turn on the same point. The *Thread* class defines several methods that can be overridden by derived class. Of these methods, the only one that must be overridden is *run()*. This is, of course, the same method required when you implement *Runnable*. Many Java programmers feel that classes should be extended only when they are being enhanced or adapted in some way. So, if you will not be overriding any of the *Thread*'s other methods, it is probably best simply to implement *Runnable*. Also, by implementing *Runnable*, your thread class doesn't need to inherit *Thread*, making it free to inherit a different class. Ultimately which approach to use is up to you.
** Using isAlive() and join()
- Often you will want the main thread to finish last. *Thread* provides two ways to determine whether a thread has finished. The first you can call is *isAlive()* on the thread. This method is defined by *Thread*, and its general form is shown here:
      final boolean isAlive()
      This method return *true* if the thread upon which it is called is still running. It returns *false* otherwise.
- While *isAlive()* is occasionally useful, the method that you will more commonly use to wait for a method to finish is called *join()*, shown here:
      final void join() throws InterruptedException
      This method waits until the thread on which it is called terminates. Its name came  from the concept of the calling thread waiting until the specified thread /joins/ it. Additional forms of *join()* allow you to specify a maximum amount of time that you want to wait for the specific thread to terminate.
- The *join()* method is used to pause the execution of the current thread until the thread it is called on has finished executing. This particularly useful when you want to ensure that a particular thread completes before the main thread or any other thread continues its execution. 
** Thread Priorities
- Thread priorities are used by the thread scheduler to decide when each thread should be allowed to run. In theory, over a given period of time, higher-priority threads get more CPU time than lower-priority threads. In practice, the amount of CPU time that a thread gets often depends on several factors besides its priority. (For example, how an operating system implements multitasking can affect the relative availability of CPU time.) A higher-priority thread can also preempt a lower-priority one. For instance, when a lower-priority thread is running and a higher-priority thread resumes (from sleeping or waiting on I/O, for example), it will preempt the lower-priority thread.
- In theory, threads of equal priority should get equal access to the CPU. But you need to be careful. Remember, Java is designed to work in a wide range of environments. Some of those environments implement multitasking fundamentally differently than others. For safety, threads that share the same priority should yield control once in a while. This ensures that all threads have a chance to run under a nonpreemptive operating system. In practice, even in nonpreemptive environments, most threads still get a chance to run, because most threads inevitably encounter some blocking situation, such as waiting for I/O. When this happens, the blocked thread is suspended and other threads can run. But, if you want smooth multithreaded execution, you are better off not relying on this. Also, some types of tasks are CPU-intensive. Such threads dominate the CPU. For these types of threads, you want to yield control occasionally so that other threads can run.
- To set a thread's priority, use the *setPriority()* method, which is a member of *Thread*. This is its general form:
      final void setPriority(int /level/)
      Here, /level/, specifies the new priority setting for the calling thread. The value of /level/ should be within the range of *MIN_PRIORITY* and *MAX_PRIORITY*. Currently, these values are 1 and 10 respectively
- You can obtain the current priority setting by calling the *getPriority()* method of *Thread*.
      final int getPriority()
- Implementations of Java may have radically different behavior when it comes to scheduling. Most of the inconsistencies arise when you have threads that are relying on preemptive behavior, instead of cooperatively giving up CPU time. The safest way to obtain predictable, cross-platform behavior with Java is to use threads that voluntarily give up control of the CPU.
** Synchronization
- When two or more threads need access to a shared resource, they need some way to ensure that the resource will be used by only one thread at a time. The process by which this achieved is called /synchronization/.
- Key to synchronization is the concept of the monitor. A /monitor/ is an object that is used as a mutually exclusive lock. Only one thread can /own/ a monitor at a given time. When a thread acquires a lock, it is said to have /entered/ the monitor. All other threads attempting to enter the locked monitor will be suspended until the first thread /exits/ the monitor. These other threads are said to be /waiting/ for the monitor. A thread that own a monitor can reenter the same monitor if it so desires.
- You can synchronize your code in either of the two ways:
  1) Using synchronized methods:
     + Synchronization is easy in Java, because all objects have their own implicit monitor associated with them. To enter an object's monitor, just call a method that has been modified with the *synchronized* keyword. While a thread is inside a synchronized method, all other threads that try to call it(or any other synchronized method) on the same instance have to wait. To exit the monitor and relinquish control of the object to the next waiting thread, the owner of the monitor simply returns from the synchronized method.
     + Remember, once a thread enters any synchronized method on an instance, no other thread can enter any other synchronized method on the same instance. However, nonsynchronized methods on that instance will continue to be callable.
  2) Synchronized statement:
     + While creating synchronized methods within classes that you create is an easy and effective means of achieving synchronization, it will not work in all cases. Imagine that you want to synchronize access to objects of a class that was not designed for multithreaded access. That is, the class does not use synchronized methods. Further, this class was not created by you, but by a third party, and you do not have access to the source code. Thus, you can’t add *synchronized* to the appropriate methods within the class. How can access to an object of this class be synchronized? Fortunately, the solution to this problem is quite easy: You simply put calls to the methods defined by this class inside a *synchronized* block. This is the general form of the *synchronized* statement:
           synchronized(/objRef/){
           // statements to be synchronized
           }
           Here, /objRef/ is a reference to the object being synchronized. A synchronized block ensures that a call to a synchronized method that is a member of /objRef/'s class occurs only after the current thread has successfully entered /objRef/'s monitor.
** Interthread Communication
- Multithreading replaces event loop programming by dividing your tasks into discrete, logical units. Threads also provide a secondary benefit: they do away will polling. Polling is usually implemented by loop that is used to check some conditions repeatedly. Once the condition is true, appropriate action is taken. This wastes CPU time. For example, consider the classic queuing problem, where one thread is producing some data and another is consuming it. To make the problem more interesting, suppose that the producer has to wait until the consumer is finished before it generates more data. In a polling system, the consumer would waste many CPU cycles while it waited for the producer to produce. Once the producer was finished, it would start polling, wasting more CPU cycles waiting for the consumer to finish, and so on. Clearly, this situation is undesirable.
- To avoid polling, Java includes an elegant interprocess communication mechanism via the *wait(), notify()*, and *notifyAll()* methods. These methods are implemented as *final* methods in *Object*, so all classes have them. All three methods can be called only from within a *synchronized* context.
  + *wait()* tells the calling thread to give up the monitor and go to sleep until some other thread enters the same monitor and calls *notify()* or *notifyAll()*.
  + *notify()* wakes up a thread that called *wait()* on the same object.
  + *notifyAll()* wakes up all the threads that called *wait()* on the same object. One of the threads will be granted access.
- These methods are declared within *Object*, as shown here:
      final void wait() throws InterruptedException
      final void notify()
      final void notifyAll()
      Additional forms of *wait()* exist that allow you to specify a period of time to wait.
- Although *wait()* normally waits until *notify() or notifyAll()* is called, there is a possibility that in a very rare cases the waiting thread could be awakened due to /spurious wakeup/. In this case, waiting thread resumes without *notify()* or *notifyAll()* having been called.(In essence the thread resumes for no apparent reason). Because of this remote possibility, the Java API documentation recommends that calls to *wait()* should take place within a loop that checks the condition on which the thread is waiting.
** Deadlock
- A special type of error that you need to avoid that relates specifically to multitasking is /deadlock/, which occurs when two threads have a circular dependency on a pair of synchronized objects.
- Deadlock is a difficult error to debug for two reasons:
  1) In general, it occurs only rarely, when the two threads time-slice in just the right way.
  2) It may involve more than two threads and two synchronized objects. (That is, deadlock can occur through a more convoluted sequence of events)
** Suspending, Resuming, and Stopping Threads
- Sometimes, suspending execution of a thread is useful.
- A thread can exist in a number of different states. You can obtain the current state of a thread by calling the *getState()* method defined by *Thread*. It's shown here:
      Thread.State getState()
      It returns a value type *Thread.State* that indicates the state of the thread at the time at which the call was made. *State* is an enumeration defined by *Thread*.(An enumeration is a list of named constants).
- Here are the values that can be returned by *getState()*:
  
  | Value         | State                                                |
  |---------------+------------------------------------------------------|
  | BLOCKED       | A thread that has suspended execution because        |
  |               | it's waiting to acquire a lock                       |
  |---------------+------------------------------------------------------|
  | NEW           | A thread that has not began execution                |
  |---------------+------------------------------------------------------|
  | RUNNABLE      | A thread that either is currently executing or will  |
  |               | execute when it gains access to CPU                  |
  |---------------+------------------------------------------------------|
  | TERMINATE     | A thread that has completed execution                |
  |---------------+------------------------------------------------------|
  | TIMED_WAITING | A thread that has suspended execution for a specific |
  |               | period of time, such as when it has called *sleep()*.  |
  |               | This state is also entered when a timeout version of |
  |               | *wait()* or *join()* is called                           |
  |---------------+------------------------------------------------------|
  | WAITING       | A thread that has suspended execution because it is  |
  |               | waiting for some action to occur. For example, it's  |
  |               | waiting because of a call to non-timeout version of  |
  |               | *wait()* or *join()*.                                    |
  |---------------+------------------------------------------------------|
- 
- It is important to understand that a thread’s state may change after the call to *getState()*. Thus, depending on the circumstances, the state obtained by calling
  *getState()* may not reflect the actual state of the thread only a moment later. For this (and other) reasons, *getState()* is not intended to provide a means of synchronizing threads. It’s primarily used for debugging or for profiling a thread’s run-time characteristics.
* Enumerations, Autoboxing, and Annotations
** Enumerations
*** What is enumeration
- An /enumeration/ is a list of named constants that define a new data type and its legal value. Thus, an enumeration object can hold only a value that was declared in the list. Other values are not allowed. In other words, an enumeration gives you a way to explicitly specify the only values that a data type can legally have. Enumerations are commonly used to define a set of values that represent a collection of items.
  For example, you might use an enumeration to represent the error codes that can result from operation, such as success, failed, or pending; or a list of states that a device might be in, such as running, stopped, or paused.
- In Java an enumerations defines a class type. By making enumerations into classes, the capabilities of enumerations are greatly expanded. For example, in Java enumeration can have constructors, methods and instance variables.
- An enumeration is created using the *enum* keyword. For example:
  #+begin_src java
    enum Apple{
        // these are enumeration constants
        // Each is implicitly declared as public static final members of Apple
        // their type is the type of enumeration they are declared, which is Apple in this
        // case.
        Jonatan, GoldenDel, RedDel, Cortland 
    }
  #+end_src
  Once you have defined an enumeration, you can create a variable of that type. However, even though enumerations defines a class type, you don't instantiate an *enum* using *new*. Instead, you declare and use an enumeration variable in which the same way as you do one of the primitive types. For example, this declares *ap* as a variable of enumeration type *Apple*:
      Apple ap;
      Because *ap* is of type *Apple*, the only values that it can be assigned(or can contain) are those defined by the enumeration. For example:
      ap = Apple.Jonatan;
- All enumerations automatically contain two predefined methods: *values()* and *valueOf()*. Their general forms are shown here:
      public static /enum-type/[] values()
      public static /enum-type/ valueOf(String str)
- *valueOf()* returns the enumeration values associated with the name of constant represented as a String.
- The *values()* method returns an array that contains a list of enumeration constants. and /enum-type/ is the type of enumeration. In the above case, the return type of Apple.valueOf("Jonatan") is Jonatan.
- A Java enumeration is a class type. Although you don't instantiate an *enum* using *new*, it otherwise has much the same capabilities as other classes. The fact that *enum* defines a class gives the Java enumeration extraordinary power. For example, you can give them constructors, add instance variable and methods, and even implement Interfaces.
- Each enumeration constant is an object of its enumeration type. Thus, when you define a constructor for an *enum*, the constructor is called when each enumeration constant is created. Also, each enumeration constant has its own copy of any instance variables defined by the enumeration.
- Here are two restrictions that apply to enumerations.
  1) enumeration cannot inherit another class
  2) an *enum* cannot be a superclass. This means that enum cannot be extended.
- Otherwise, *enum* acts much like any other class type. The key is to remember that each of the enumeration constant is an object of the class in which it is defined.
- Although you can't inherit a superclass when declaring an *enum*, all enumerations automatically inherit one: *java.lang.Enum*. This class defines several methods that are available for use by all enumerations. Three methods of *Enum* that worth discussing:
  + You can obtain a value that indicates an enumeration constant's position in the list of constants. This is called its /ordinal value/, and it is retrieved by calling the *ordinal()* method, shown here:
        final int ordinal()
        It returns the ordinal value of the invoking constant. Ordinal values begin at zero. Thus, in the above *Apple* enumeration, *Jonatan* has an ordinal value of zero.
  + You can compare the ordinal value of two constants of the same enumeration by using *compareTo() method. It has this general form:
        final int compareTo(/enum-type/ e)
        Here, /enum-type/ is the type of the enumeration, and /e/ is the constant being compared to the invoking constant. Remember, both the invoking constants and /e/ must be of the same enumeration. If the invoking constant has an ordinal value less than /e/'s, then *compareTo()* returns a negative value, zero if equal and positive if greater.
  + You can compare for equality an enumeration constant with any other object by using *equals()*, which overrides the *equals()* method defined by *Object*. Although *equals()* can compare an enumeration constant to any other object, those two objects will be equal only if they both refer to the same constant, within the same enumeration. Simply having ordinal values in common will not cause *equals()* to return true if the two constants are from different enumerations. Remember you can compare two enumeration references for equality by using ==.
*** Type wrappers
- Java uses primitive types(also called simple type) such as *int*, or *double*, to hold the basic data types supported by the language. Primitive types are used for the sake of performance. Primitive types are not part of the object hierarchy and they don't inherit *Object*.
- Despite the performance benefit offered by the primitive types, there are times when    you will need an object representation. For example, you can't pass a primitive type reference to a method. Also, many of the standard data structures implemented by Java operate on objects, which means they can't use those data structures to store primitive types. To handle this(and other) situations, Java provides /type wrappers/, which are classes that encapsulate a primitive type within an object.
- The type wrappers are *Double, Float, Long, Integer, Short, Byte, Character*, and *Boolean*.
- *Character*
  + Is wrapper around *char*. The constructor is:
        Character(char ch)
  + However, beginning JDK 16, the *Character* constructor has been deprecated for removal. Today it's strongly recommended that you use the static method *valueOf()* to obtain *Character* object. It is shown here:
        static Character valueOf(char ch).
        It returns a *Character* object that wraps ch.
  + To obtain that *char* value contained in *Character* object, call *charValue()*, shown here:
        char charValue()
        It returns the encapsulated character.
- *Boolean*
  + *Boolean* is a wrapper around *boolean* values. It defines those constructors:
        Boolean(boolean boolValue) -> here boolValue must be either true or false
        Boolean(String boolString) -> if boolString contains the string "true" (in upper case or lowercase), then the new *Boolean* object will be true. Otherwise it will be false.
  + However beginning JDK 16, the *Boolean* constructor were deprecated for removal. Today it's strongly recommended that you use the static method *valueOf()* to obtain a *Boolean* object. It has the two versions shown here:
        static Boolean valueOf(boolean boolValue)
        static Boolean valueOf(boolean boolString)
        Each returns a *Boolean* object that wraps the indicated value.
  + To obtain a *boolean* value from the *Boolean* object, use *booleanValue()* method shown here:
        boolean booleanValue()
        It returns the *boolean* equivalent of the invoking object.
- *Numeric Type Wrappers*
  + By far, the most commonly used type wrappers are those that represent numeric values. These are *Byte, Short, Integer, Long, Float* and *Double*. All of the numeric type wrappers inherit the abstract class *Number*. *Number* declares methods that return the value of an object in each of the different number formats. These methods are:
    - byte byteValue()
    - short shortValue()
    - int intValue()
    - long longValue()
    - float floatValue()
    - double doubleValue()
      These methods are implemented by each of the numeric type wrappers
  + All of the numeric type wrappers define constructors that allow an object to be constructed from a given value, or a string representation of that value.
    For example for Integer:
        Integer(int num)
        Integer(String str)
        If /str/ doesn't contain a valid number value, then a *NumericFormatException* is thrown.
  + However, beginning with JDK 16 the numeric type-wrapper constructor have been deprecated for removal. Today, it is strongly recommended that you use one of the *valueOf()* methods to obtain a wrapper object.
** Autoboxing and Auto unboxing
- Autoboxing is the process by which a primitive type is automatically encapsulated(boxed) into its equivalent type wrapper whenever an object of that type is needed. There is no need to explicitly construct an object. Auto-unboxing is the process by which the value of boxed object is automatically extracted(unboxed) from a type wrapper when its value is needed. There is no need to call a method such as *intValue()* or *doubleValue()*.
- Autoboxing making working with Collections Framework much easier.
- With autoboxing, it is not necessary to manually construct an object in order to wrap a primitive type. You need only assign that value to a type-wrapper reference. Java automatically constructs the object for you.
  For example, to constructor an *Integer* that a value 100:
      Integer iOb = 100; -> autobox an int.
      int i = iOb; -> auto-unboxed
- In general, autoboxing and unboxing takes place whenever a conversion into an object or from an object is required. This applies to expressions. For example:
      Integer iOb;
      ++iOb; // this will unbox and increment it then re-box it to the object reference.
- Java also supplies wrappers for *boolean* and *char*. These are *Boolean* and *Character*. Autoboxing/unboxing applies to those wrappers, too.
  #+begin_src java
    Boolean b = true;
    // below, b is auto-unboxed when used in a conditional expression
    // such as as in if, when Boolean is used in condtions it is automatically into its
    // boolean equivalent
    if(b) System.out.println("b is true");

    Character ch = 'A'; // box a char
    char ch2 = ch; // auto-unbox
  #+end_src
- In general, you should restrict your use of type wrappers to only those cases in which an object representation of a primitive type is required. Autoboxing/unboxing was not added to Java as a "back door" way of eliminating the primitive types.
** Annotations
*** Annotation Basics
- Java provides a feature that enables you to embed supplemental information into a source file. This information, called /annotation/, does not change the action of the program. Thus an annotation leaves the semantic of a program unchanged. However, this information can be used by various tools during both development and deployment.
- An annotation is created through a mechanism based on the *interface*
- All annotations consist solely of method declaration. However, you don't provide bodies for these methods. Instead, Java implements those methods. Moreover, the methods act much like fields.
- An annotation can't include an *extends* clause. However, all annotation types automatically extends the *Annotation* interface. Thus, *Annotation* is a super-interface of all annotation types. It's declared within *java.lang.annotation* package
- Any type of declaration can have an annotation associated with it. classes, methods, fields, parameters, and enum constants can be annotated. Even annotation can be annotated. In all cases, the annotation precedes the rest of the declaration.
- When you apply annotation, you give values to its members.

*** Retention Policy
- A retention policy determines at what point an annotation is declared. Java defines three such policies, which are encapsulated within the *java.lang.annotation.RetentionPolicy* enumeration. They are *SOURCE, CLASS* and *RUNTIME*.
- An annotation with a retention policy of *SOURCE* is retained only in the source file and is discarded during compilation.
- An annotation with a retention policy of *CLASS* is stored in the *.class* file during compilation. However, it is not available through the JVM during runtime.
- An annotation with a retention policy of *RUNTIME* is stored in the *.class* file during compilation and is available through the JVM during runtime. Thus, *RUNTIME* retention offers the greatest annotation persistence.
- *NOTE*: an annotation on local variable declaration is not retained in the *.class* file.
- A retention policy is specified for an annotation by using Java's built-in annotation: *@Retention*. Its general form is show here:
      @Retention(/retention-policy/)
      Here, /retention-policy/ must be one of *SOURCE, CLASS, RUNTIME*. If not retention policy is specified for the annotation, then the default policy of the annotation of *CLASS* is used.
- Although annotation are designed mostly for use by other development or deployment tools, if they specify the retention policy of *RUNTIME*, then they can be queried at run time by any Java program through the use of /reflection/. Reflection is a feature that enables information about a class to be obtained at runtime. The reflection API is contained in the *java.lang.reflect* package.
- You can obtain all annotations that have *RUNTIME* retention that are associated with an item by calling *getAnnotations()* on that item. It has this general form:
      Annotation[] getAnnotations()
      It returns an array of annotations. *getAnnotations()* can be called on objects of type *Class, Method, Constructor* and *Field*, among others.
- *AnnotatedElement Interface*
  + Methods like *getAnnotations()* and *getAnnotation()* are defined by the *AnnotatedElement* interface, which is defined in *java.lang.reflect*.
- *Using default values*
  + You can give annotation members default values that will be used if no value is specified when the annotation is applied. A default value is specified by adding *default* clause to a member's declaration. It has this general form:
        /type member() default value;/
        Here /value/ must be of type compatible with the /type/.
        e.g: String str() default "Default annotation";
- *Marker Annotation*
  + A /marker/ annotation is a special kind of annotation that contains no members. Its sole purpose is to mark an item. Thus, its presence as an annotation is sufficient. The best way to determine if a marker annotation is present is to use the method is *isAnnotationPresent()* which is defined by the *AnnotatedElement* interface.
- *Single member Annotation*
  + A /single-member/ annotation contains only one member. It works like normal annotation except that it allows a shorthand form specifying the value of the member. When only one member is present you can specify the value for that member when the annotation is applied-- you don't need to specify the name of the member. However, in order to use this shorthand, the name of the member must be *value*.
  + You can use the single-value syntax when applying an annotation that has other members, but those other members must all have default values.
  + *Remember, whenever you are using a single-member annotation, the name of that member must be /value/.*
- *Built-in Annotations*
  + Java defines many built-in annotations. Most are specialized, but nine are general purpose. Of those, four are imported from *java.lang.annotation: @Retention, @Documented, @Target* and *@Inherited*. Five -- *@Override, @Deprecated, @FunctionalInterface, @SafeVarargs* and *@SuppressWarnings* -- are included in *java.lang*.
  + *java.lang.annotation* also includes the annotations *Repeatable* and *Native*. *Repeatable* supports repeatable annotations, where as *Native* annotates a field that can be accessed by native code.
  + *@Retention*
    - Is designed to be used only as an annotation to another annotation. It specifies the retention policy.
  + *@Documented*
    - This is a marker interface that tells a tool that an annotation is to be documented. It is designed to be used only as an annotation to an annotation declaration.
  + *@Target*
    - This specifies the type of item to which an annotation can be applied. It's designed to be used only as annotation to another annotation. *@Target* takes one argument, which is an array of constants of *ElementType* enumeration. This argument specifies the type of declaration to which the annotation can be applied.

      | Target Constant | Annotation can be applied to    |
      |-----------------+---------------------------------|
      | ANNOTATION_TYPE | Another annotation              |
      |-----------------+---------------------------------|
      | CONSTRUCTOR     | Constructor                     |
      |-----------------+---------------------------------|
      | FIELD           | Field                           |
      |-----------------+---------------------------------|
      | LOCAL_VARIABLE  | Local variable                  |
      |-----------------+---------------------------------|
      | METHOD          | Method                          |
      |-----------------+---------------------------------|
      | MODULE          | Module                          |
      |-----------------+---------------------------------|
      | PACKAGE         | Package                         |
      |-----------------+---------------------------------|
      | PARAMETER       | Parameter                       |
      |-----------------+---------------------------------|
      | TYPE            | Class, interface or enumaration |
      |-----------------+---------------------------------|
      | TYPE_PARAMETER  | Type parameter                  |
      |-----------------+---------------------------------|
      | TYPE_USE        | Type use                        |
      |-----------------+---------------------------------|

    - You can specify one or more of these values in a *@Target* annotation. To specify multiple values, you must specify them within a braces-delimited list.
      For example:
      /@Target({ElementType.FIELD, ElementType.LOCAL_VARIABLE})/
    - If you don't use *@Target*, then the annotation can be used on any declaration. For this reason, it is often a good idea to explicitly specify the target or targets so as to clearly indicate the intended uses of an annotation.
  + *@Inherited*
    - This is a marker annotation that can be used only on another annotation declaration. Furthermore, it affects only annotations that will be used on class declarations. *@Inherited* causes the annotation for a superclass to be inherited by a subclass.
  + *@Override*
    - Is a marker annotation that can be used only on methods. A method annotated with *@Override* must override a method from superclass. If it doesn't, a compile-time error will result.
  + *@Deprecated*
    - This indicates that a declaration is obsolete and not recommended for use. This also allows you to specify the Java version in which the deprecation occurred and whether the deprecated element is slated for removal.
  + *@FunctionalInterface*
    - This is a marker annotation designed for use on interfaces. It indicates that the annotated interface is a functional interface.
    - Note that: *@FunctionalInterface* is not needed to create a functional interface, it just makes sure that interface is a functional interface, it is purely informational. Any interface with exact one abstract method is, by definition, a functional interface.
  + *@SafeVarargs*
    - This is a marker annotation that can be applied to methods and constructors. It indicates that no unsafe actions related to a varargs parameter occur.
  + *@SuppressWarnings*
    - This specifies that one or more warnings that might be issued by the compiler are to be suppressed. The warning to suppress are specified by name, in string form.
- *Repeating Annotations*
  + An annotation that can be repeated on the same element is called /repeating annotations/. For an annotation to be repeatable, it must be annotated with *@Repeatable* annotation, defined in *java.lang.annotation*. Its *value* field specifies the /container/ type for the repeatable annotation.
- *Some Restrictions*
  1) No annotation can inherit another
  2) All methods declared by an annotation must be without parameters
  3) They must retain one of the following:
     - A primitive type, such *int* or *double*
     - An object type *String* or *Class*
     - An object of an *enum* type
     - An object of another annotation type
     - An array of legal type.
  4) An annotation can not be generic(they can't take type parameters).
  5) Annotation methods cannot specify *throws* clause.

* Lambda expressions
** What is Lambda
+ Added by JDK 8, lambda expression significantly enhanced Java because of two primary reasons:
  1) They added new syntax elements that increased the expressive power of the language. In the process, they streamlined the way that certain common constructs are implemented.
  2) New capabilities being incorporated into the API library. Among the new capabilities are the ability to more easily take advantage of the parallel processing capabilities of multi-core environment, especially as it relates to the handling of for-each style operations, and the new stream API, which supports pipeline operations on data.
+ The addition of lambda expressions also provided the catalyst for other new Java features, including the /default method/, which lets you define a default behavior for interface methods, and the /method reference/, which lets you refer to a method without executing it.
+ Keys to understanding Java's implementation of lambda expressions are two constructs.
  1) lambda expression itself
  2) functional interface
     
+ A /lambda expression/ is, essentially, an anonymous(that is, unnamed) method. However, this method in not executed on its own. Instead, it is used to implement a method defined by a functional interface. Thus, a lambda expression results in a form of anonymous class. Lambda expressions are also commonly referred to as closures.
+ A /functional interface/ is an interface that contains one and only one an abstract method. Normally, this method specifies the intended purpose of the interface. Thus a functional interface typically represents a single action.
  For example, the standard interface *Runnable* is a functional interface because it defines only one method: *run()*. Therefore, *run()* defines the action of *Runnable*. Furthermore, a functional interface defines the /target type/ of a lambda expression. *A lambda expression can be used only in a context in which its target type is specified*.
+ A functional interface is sometimes referred to as a /SAM type/, where SAM stands for Single Abstract Method.
+ A functional interface may specify any public method defined by *Object*, such as *equals()*, without affecting its "functional interface status". The public *Object* methods are considered implicit members of functional interface because they are automatically implemented by an instance of functional interface.
+ The /lambda operator/ or the /arrow operator/ is *\to*. It divides a lambda expression into two parts. The left side specifies any parameter required by the lambda expression. (If no parameters are required, an empty parameter list is used). On the right side is the /lambda body/, which specifies the actions of the lambda expression.
+ The \to can be verbalized as "becomes" or "goes to".
+ Java defines two types of lambda bodies.
  1) consisting of single expression
  2) consisting block of code.
+ In order for a lambda expression to be used in a target context, the type of the abstract method the type of the lambda expression must be compatible. For example, if the abstract method specifies two *int* parameters, then the lambda must specify two parameters whose type is either explicitly *int* or can be implicitly inferred as *int* by the context.
+ In general, the type and number of lambda expression's parameter must be compatible with the method's parameters; the return types must be compatible; and any exception thrown by the lambda expression must be acceptable to the method.
+ When lambda expression has only one parameter, it is not necessary to surround the parameter name with parentheses when it is specified on the left side of the lambda operator, and the data type of the input parameter can be explicit or implicit.
+ Whenever more than one parameter is required, the parameters are specified, separated by commas, in a parenthesized list on the left side of the lambda operator.
+ *Note*: If you need to explicitly declare the types of parameter, then all of the parameters must have declared types. For example, this is legal
  #+begin_src java
    (int n, int d) -> (n%d) == 0; // legal
    (int n, d) -> (n%d) == 0;  //  not legal
  #+end_src
+ Lambda expressions that consists only single expression on the right side of the lambda operator are referred to as /expression bodies/, and lambdas that have expression bodies are sometimes called, /expression lambdas/.
+ /block body/ is a lambda expression that consists a block of code on the right side of the lambda operator. Lambdas that have block bodies are sometimes referred to as /block lambdas/. Block lambdas are much like the expression lambdas, one key difference; however, is that you must explicitly use a *return* statement to return a value. This is necessary because a block lambda body doesn't represent a single expression.
+ The block body of a lambda is similar to a method body. When a return statement occurs within a lambda expression, it simply causes a return from the lambda. It doesn't cause an enclosing method to return.
+ A lambda expression, itself, can not specify type parameters. Thus, a lambda expression can not be generic. However, the functional interface associated with the lambda expression can be generic. In this case, the target part of lambda expression is determined, in part, by the type argument or arguments specified when a functional interface is declared.
+ Lambda expression can be as an argument. This is very powerful because it gives a way to pass executable code as an argument to a method.
+ To pass a lambda expression as an argument, the type of parameter receiving the lambda expression argument must be of a functional interface type compatible with the lambda.
** Method Reference
+ A method reference provides a way to refer a method without executing it. It relates to lambda expressions because it, too, requires a target type context that consists of a compatible functional interface. When evaluated, a method reference also creates an instance of the functional interface.
+ *Method references to static methods*
  - To create a *static* method reference, use this general form:
       ClassName::methodName
       Notice that the class name is separated from the method name by a double colon(::).
       This method reference can be used anywhere in which it is compatible with its target type.
+ *Method references to Instance Methods*
  - To pass a reference to an instance method on a specific object, use this basic syntax:
        objRef::methodName
        The syntax is similar to that used for *static* method, except that an object reference is used instead of a class name.
  - It is also possible to handle a situation in which you want to specify an instance method that can be used with any object of a given class -- not just a specified object. In this case, you will create a method reference as shown below:
        ClassName::instanceMethodName;
        Here, the name of the class is used instead of a specific object, even though the instance method is specified.
+ *Method references with Generics*
  - You can use method reference with generic classes and/ or generic methods.
+ *Constructor reference*
  - Similar to the way that you can create reference to methods, you can create reference to constructors. Here is the general form of syntax:
        classname::new
        This reference can be assigned to any functional interface reference that defines a method compatible with the constructor.
  - Constructor reference to generic classes are created in the same fashion. The only difference is that the type argument can be specified. This works the same as it does for using generic class to create a method reference: simply specify the type argument after the class name.
  - There is a second form of constructor reference that is used for arrays. To create a constructor reference for an array, use this construct:
        /type/[]::new
        Here, /type/ specifies the type of the object being created.
+ *Predefined Functional Interface*
  - A package called *java.util.function* provides several predefined functional interfaces, here is a sample:

    |-------------------+-----------------------------------------------------------|
    | Interface         | Purpose                                                   |
    |-------------------+-----------------------------------------------------------|
    | UnaryOperator<T>  | Apply unary operator and returns *T*                        |
    |                   | its method is *apply()*                                     |
    |-------------------+-----------------------------------------------------------|
    | BinaryOperator<T> | Apply an operation to two object type *T* and return the    |
    |                   | result, which also type *T*. Its method is *apply()*          |
    |-------------------+-----------------------------------------------------------|
    | Consumer<T>       | Apply an operation on an object type *T*. Its method is     |
    |                   | called *accept()*                                           |
    |-------------------+-----------------------------------------------------------|
    | Supplier<T>       | Returns an object type *T*. Its method is *get()*             |
    |-------------------+-----------------------------------------------------------|
    | Function<T,R>     | Apply an operation to an object type *T* and returns the    |
    |                   | object as an object type R. Its method *apply()*            |
    |-------------------+-----------------------------------------------------------|
    | Predicat<T>       | Determines if an object of type *T* fulfils some constraint |
    |                   | Returns a *boolean* value that indicates the outcome.       |
    |                   | Its method is called *test()*                               |
    |-------------------+-----------------------------------------------------------|

* I/O
** I/O Basics
*** Streams
**** What is Stream
+ Java programs perform I/O through streams. A /stream/ is an abstraction that either produces or consumes information. A stream is linked to a physical device by the Java I/O system. All streams behave in the same manner, even if the actual physical device to which they are linked differ. Thus, the same I/O classes and methods can be applied to different types of device. This means that an input stream can abstract many different kinds of input: from a disk file, a keyboard, or a network socket. Likewise, an output stream may refer to the console, disk file, or a network connection. Streams are a clean way to deal with input/output without having every part of your code understand the difference between a keyboard and a network.
+ *Note*: In addition to the stream-based I/O defined in *java.io*, java also provides buffer-based and channel-based I/O, which is defined in *java.nio* and its packages.
**** Byte Streams and Character Streams
- Java defines two types of I/O streams: byte and character. /Byte streams/ provide a convenient means for handling input and output of bytes. Byte streams are used when, for example, when reading or writing binary data(like character, image, audio, videos...) /Character streams/ provide a convenient means for handling input and output of character data(text data). They use Unicode and, therefore, can be internationalized.
- The original version of Java(1.0) did not include character stream and thus, all I/O was byte-oriented.
- At lowest level all I/O is still byte-oriented. The character-based streams simply provides a convenient and efficient means for handling characters.
**** The Byte Stream Classes
- Byte streams are defined by using two class hierarchies. At the top are two abstract classes: *InputStream* and *OutputStream*. Each of these abstract classes has several concrete subclasses that handle the differences among various devices, such as disk file, network connections, and even memory buffers.
- *Remember*, to use the stream classes, you must import *java.io.**
- The abstract classes *InputStream* and *OutputStream* defines several key methods that other stream class implement. Two of the most important are *read()* and *write()*, which respectively, read and write bytes of data.
**** The Character Stream Classes
- Character streams are defined using two class hierarchies. At the top are two abstract classes: *Reader* and *Writer*. These abstract classes handle Unicode character streams.
- The abstract classes *Reader* and *Writer* defines several key methods that other stream class implement. Two of the most important are *read()* and *write()*, which read and write character of data, respectively
**** The Predefined Streams
- All Java code automatically import the *java.lang* package. This package defines a class called *System*, which encapsulates several aspects of the run-time environment. *System* also contains three predefined stream variables: *in, out* and *err*. These field are defined as *public, static* and *final* within the *System*. This means that they can be used by any part of your program and without reference to a specific *System* object.
  
  Here is a definition of *out, err*, and *in* respectively:
      /public static final PrintStream out;/
      /public static final PrintStream err;/
      /public static final InputStream in;/

- *System.in* is an object of type of *InputStream*; *System.out* and *System.err* are objects of type *PrintStream*. These are byte streams, even though they are typically used to read and write characters from and to the console. You can wrap these within character-based stream, if desired.
- *System.out* refers to the standard output stream. By default this is the /console./ *System.in* refers to the standard input, which the /keyboard/ by default. *System.err* refers to the standard error stream, which is also the /console/ by default. However, these streams may be redirected to any compatible I/O device.
  
*** Reading Console input
- In the early days of Java, the only way to perform console input was to use the byte stream. Today, using byte stream to read console input is still acceptable, but for commercial applications, the preferred method of reading console input is to use character-oriented stream. This makes you program easier to internationalize and maintain.
- In Java, console input is accomplished(either directly or indirectly) by reading from *System.in*. One way to obtain a character-based stream that is attached to the console is to wrap *System.in* in a *BufferedReader*. The *BufferedReader* class supports a buffered input stream. A commonly used constructor is shown here:
      /BufferedReader(Reader inputReader )/
      Here, /inputReader/ is the stream that is linked to the instance of *BufferedReader* that is being created. *Reader* is an abstract class. One of its concrete subclass is *InputStreamReader*, which converts bytes to characters.
      
*** Reading Characters
- To read a character from a *BufferedReader()*, use *read()*. The version of *read()* that we will be using is:
      /int read() throws IOException/
      Each time that *read()* is called, it reads a character from the input stream and returns it as an integer value. It returns -1 when an attempt is made to read the end of the stream. And it throws an *IOException*.

*** Reading Strings
- To read a string from the keyboard, the version of *readLine()*, that is the member of *BufferedReader* class. Its general form is:
      /String readLine() throws IOException/
      As you can see, it returns a String object
*** Writing Console Output
- Console output is most easily accomplished with *print()* and *println()*. These methods are defined by the class *PrintStream* (which is type of object referenced by *System.out*). Even though *System.out* is a byte stream, using it for simple program output is still acceptable.
- Because *PrintStream* is an output stream derived from *OutputStream*, it also implements the low level method *write()*. Thus, *write()* can be used to write to the console. The simplest form of *write()* defined by *PrintStream* is:
      /void write(int byteval)/;
      This method writes the byte specified by /byteval/. Although /byteval/ is declared as integer, only the low-order eight bits are written.
*** The PrintWriter Class
- Although using *System.out* to write to the console is acceptable, its use is probably best for debugging purposes or for sample programs, for real-world programs, the recommended method of writing to the console when using Java is through a *PrintWriter* stream. *PrintWriter* is one of the character-based classes. Using character-based class for console output makes internationalizing your program easier.
- *PrintWriter* defines several constructors. But the common one is:
       PrintWriter(OutputStream /OutputStream/, boolean /flushingOn/);
       Here, the /OutputStream/ is an object of type *PrintStream*, and /flushingOn/ controls whether Java flushes the output stream every time a *println()* method(among others) is called. If /flushingOn/ is *true*, flushing automatically takes place. If *false*, flushing is not automatic.
- *PrintWriter* supports the *print()* and *println()* methods. Thus, you can use these methods in the way as you used them with *System.out*.
- To write to the console by using a *PrintWriter*, specify *System.out* for the output stream and automatic flushing.
  
  #+begin_src java
    import java.io.PrintWriter;
    PrintWriter pw = new PrintWriter(System.out, true);
    pw.println("This a string typed via PrintWriter");
  #+end_src
- There is nothing wrong with using *System.out* to write to the console, but using a *PrintWriter* makes your real-world application easier to internationalize.
*** Reading and Writing Files
- Java provides a number of classes and methods that allow you to read and write  files.
- Two of the most often-used stream classes are *FileInputStream* and *FileOutputStream*, which creates byte streams linked to the file. To open a file, you simply create an object of one of these classes, specifying the name of the file as an argument to the constructor. Although both classes support additional constructors, the following are the common:
      FileInputStream(String /fileName/) throws FileNotFoundException
      FileOutputStream(String /fileName/) throws FileNotFoundException
      Here, /fileName/ specifies the name of the file you want to open. When an output file is opened, any preexisting file the name is destroyed.
- When you are done with a file, you must close it. This is done by calling the *close()* method, which is implemented by both *FileInputStream* and *FileOutputStream*. It is show here:
      void close() throws IOException
- Closing a file releases the system resource allocated to the file, allowing them to be used by other file. Failure to close a file an result in "memory leaks" because unused resources remaining unallocated.
- There are *two* basic approaches that you can use to close a file when you are done with it.
  1) When *close()* is called explicitly. This is a traditional approach which is used by all version of Java prior to JDK 7.
  2) *try*-with-resource statement: this is added by JDK 7, which automatically closes a file when it is no longer needed. In this approach no explicit call to *close()* is executed.
- To read from a file, you can use a version of *read()* that is defined within *FileInputStream*. One form is:
      int read() throws IOException
      Each time it's called, it reads a single byte from the file and returns the byte as as integer value. *read()* returns -1 when an attempt is made to read at the end of the stream. It can throw  an *IOException*.
*** Automatically Closing A File
- Prior to Java JDK 7, programs have to made explicit calls to *call()* to close a file once the file is no longer needed. But JDK 7 added a feature for automating the closing process. This feature, sometimes referred to as /automatic resource management/, or /ARM/ for short, is based on an expanded version of *try* statement. The principal advantage of /ARM/ is that it prevents situations in which a file(or other resources) is inadvertently not released after it is no longer needed.
  Here is the general form:
       try(/resource specification/){
           // use the resource
       }
- Typically, /resource-specification/ is a statement that declares and initializes a resource, such as a file system. It consists of a variable declaration in which the variable is initialized with a reference to the object being managed. When the *try* block ends, the resource is automatically released. In the case of a file, this means that the file automatically closed. Of course, this form of *try* can also include *catch* and *finally* clauses. This forms of *try* is called *try*-/with-resource/ statement.
- *Note*: Beginning with JDK 9, it is also possible for the resource specification of the *try* to consist of a variable that has been declared and initialized earlier in the program. However, that variable must be effectively final, which means that it has not been assigned a new value after being given its initial value.
- The *try*-with-resources statements can be used only with those resources that implement the *AutoCloseable* interface defined by the *java.lang*. This interface defines the *close()* method. *AutoCloseable* is inherited by the *Closable* interface in *java.io*. Both interfaces are implemented by the stream classes. Thus, *try*-with-resource can be used when working with streams, including file streams.
- It is important to understand that a resource declared in the *try* statement is implicitly *final*. This means that you can't assign to the resource after it has been created. Also the scope of the resource is limited to the *try*-with-resource statement.
- You can use local variable inference to specify the type of the resource declared in *try*-with-resources statement. To do so, specify the type as *var*. When this is done, the type of resource is inferred from its initializer.
  e.g:
      try(var fin = new FileInputStream(args[0])){}
      Here, *fin* is inferred to be of type *FileInputStream* because that is the type of its initializer.
- *You can manage more than one resources within single /try/ statement. To do so, simply separate each resource specification with a semicolon(;)*.
- The ability to streamline - made efficient by stripping off non essentials - source code is a side-benefit of automatic resource management.
- In general, when a *try* block executes, it is possible that an exception inside the *try* block will lead another exception that occur when the resource is closed in a *finally* clause. In the case of a "normal" *try* statement, the original exception is lost, being preempted by the second exception. However, when using *try*-with-resources, the second exception is /suppressed/. It's not, however, lost. Instead it's added to the list of suppressed exception associated with the first exception. The list of suppressed exceptions can be obtained by using the *getSuppressed()* method defined by *Throwable*.
*** The transient and volatile Modifiers
- English definition of transient - Remaining for only a brief time
- English definition of volatile - Evaporating
- Java defines two interesting type modifiers: *transient* and *volatile*. These modifiers are used to handle somewhat specialized situations. When an instance variable is declared as *transient*, its value need not persist when an object is stored.
  For example:
  #+begin_src java
    class T{
        transient int a; // will not persist
        int b; // will persist
    }
  #+end_src
  Here, if an object of type *T* is written to a persistent storage area, the content of *a* would not be saved, but the content of *b* would.
- The *volatile* modifier tells the compiler that the variable modifier by *volatile* can be changed unexpectedly by other parts of your program. One of these situations involves multi-threaded programs. In multi-threaded program, sometimes two or more threads share the same variable. For efficiency considerations, each thread can keep its own, private copy of such a shared variable. The real(or master) copy of the variable is updated at various times such as when a *synchronized* method is entered. While this approach works fine, it may be inefficient at times. In some cases, all that really matters is that the master copy of a variable always reflects its current state. To ensure this, simply specify the variable as *volatile*, which tells the compiler that it must always use the master copy of the *volatile* variable(or, at least always keep any private copies up-to-date with the master copy, and vice versa). Also access to the shared variable must be executed in the precises order indicated by the program.
*** Introducing instanceof
- Sometimes, knowing the type of an object during time is useful. For example, you might have one thread of execution that generates various types of objects, and another thread that processes these objects. In this situation, it might be useful for the processing the thread to know the type of each object when it receives it. Another situation may be run time casting.
- The traditional *instanceof* operator has this general form:
      /objref/ instanceof /type/
      Here, /objref/ is a reference to an instance of a class, and /type/ is a class type. If /objref/ is of the specified type or can be cast into the specified type, then the *instanceof* evaluates to *true*. Otherwise the result is *false*. Thus, *instanceof* is the means by which your program can obtain run-time information about an object.
*** Native Methods
...
*** Using assert
- It is used during program development to create an /assertion/, which a condition that should be true during the execution of the program. Assertions are often used during testing to verify that some expected condition is actually met.
- The *assert* keyword has two forms.
  1) assert /condition/;
     Here, /condition/ is an expression that must evaluate to a Boolean result. If the result is true, then the assertion is true and no other action takes place. If the result is false, then the assertion fails and a default *AssertionError* object is thrown.
  2) assert condition: /expr/;
     In this version, /expr/ is a value that is passed to *AssertionError* constructor. This value is converted to its string format and displayed if an assertion fails. Typically, you will specify a string for /expr,/ but any non-*void* expression is allowed as long as it defines a reasonable string conversation.
- To enable assertion checking at run time, you must specify the *-ea* option. For example, to enable assertion for *AssertDemo*, execute it using this line:
      java -ea AssertDemo
*** Assertion Enabling and Disabling options
...
*** Static import
- Java includes a feature called /static import/ that expands the capability of the *import* keyword. By following *import* with the keyword *static*, an *import* statement can be used to import the static members of a class or interface. When using static import, it is possible to refer to static members directly by their names, without having to qualify them with the name of their class. This simplifies and shortens the syntax required to use a static member.
- For example, to brought *sqrt and pow* from Math class in java.lang class you can use:
       import static java.lang.Math.sqrt;
       import static java.lang.Math.pow;
       After these statements, it is no longer necessary to qualify *sqrt()* or *pow()* with their class name.
- There are two general forms of *import static* statements.
  1) import static pkg.type-name.static-member-name;
     Here, /type-name/ is the name of the class or interface that contains the desired static member. Its full package name is specified by /pkg/. The name of the member is specified by /static-member-name/
  2) import static pkg.type-name.*;
     This forms imports all static members of a given class or interface.
- As convenient as static import can be, it is important not to abuse it. Remember, the reason that Java organizes its libraries into package is to avoid namespace collisions. When you import static members, you are bringing those members into the current namespace. Thus, you are increasing the potential for namespace conflict and inadvertent name hiding.
- If you are using a static member once or twice in the program, it's best not to import it. Static import is designed for those situations in which you are using a static member repeatedly, such as when performing a series of mathematical computations. In essence, you should use, but not abuse, this feature.
* Generics
** General Overview
- /generics/ introduced in JDK 5 Java, since that /generics/ changed Java in two ways:
  1) /Generics/ add new syntactical element to the language
  2) It caused changes to many of the classes and methods in core Java API
- Through the use of generics, it is possible to create classes, interfaces, and methods that will work in a type-safe manner with various kinds of data. Many algorithms are logically the same no matter the type of data they are being applied to. For example, the mechanism that supports a stack is the same whether the stack is storing items of type *Integer, String, Object* or *Thread*. With generics, you can define an algorithm once, independently of any specific type of data, and then apply the algorithm to a wide variety of data types without any additional efforts.
- Perhaps the one feature of Java that was most significantly affected by generics is the /Collections Framework/. A /Collection/ is a group of objects. The Collections Framework defines several classes, such as lists and maps that manage collections. The collection classes had always been able to work with any type of object. The benefit that generics added is the ability to use the collection classes with complete type-safety.
** What Are Generics?
- At its core, the term generics means /parameterized types/. Parameterized types enable you to create classes, interfaces, and methods in which the type of data upon which they operate is specified as a parameter. Using generics, it is possible to create a single class, for example, that automatically works with different types of data. A class, interface, or method that operates on parameterized types is called /generic/, as in /generic class/ or /generic method/.
- Java has given you the ability to create generalized classes, interfaces, and methods by operating through reference of type *Object*. Because *Object* is the superclass of all other classes, an *Object* reference can refer to any type object. Thus, in pre-generics code, generalized classes, interfaces and methods used *Object* reference to operate on various types of objects. The problem was that they could not do so with type safety. Generics added the type safety that was lacking. They also streamline the process, because it is no longer necessary to explicitly employ casts to translate between *Object* and the type of data that it actually being operated upon. With generics, all casts are automatic and implicit. Here is an example how /generic/ class is declared.

  #+begin_src java
    class Gen<T>{
        ...
    }
  #+end_src
- Here *T* is the name of /type parameter/. This name is used as a placeholder for the actual type that will be passed to *Gen* when an object is created. In declaration of *Gen*, there is no special significance to the name *T*. Any valid identifier could have been used, but *T* is traditional. Furthermore, it's recommended that type parameter names be single-character capital letters.
** Why Use Generics?
- Generics enables *types* (classes and interfaces) to be parameters when defining classes, interfaces and methods. Much like the formal parameters used in method declarations, type parameters provide a way for you to re-use the same code with different inputs. The difference is that the inputs to formal parameter are values, while the inputs to /type parameters/ are /types/.
- Code that use generics has many benefits over non-generic code:
  + Stronger type check at compile time. Fixing compile time error is easier than fixing runtime errors, which can be difficult to find.
  + Elimination of casts.
  + Enabling programmers to implement generic algorithms.
- *Type Parameter naming convention:* By convention, type parameter names are single, uppercase letters. This stands in sharp contrast to the variable naming conventions and with a good reason: without this convention, it would be difficult to tell the difference between a type variable and an ordinary class or interface name. The most commonly used type parameter names are: E(Element), K(Key), N(Number), T(Type), V(Value).
** Generics Work Only With Reference Types
- When declaring an instance of a generic type, the type argument passed to the type parameter must be a reference type. You can't use primitive types, such as *int* or *char*. Of course, not being able to specify a primitive type is not a serious restriction because you can use the type wrappers to encapsulate a primitive type. Further, Java's auto boxing and auto-unboxing mechanism makes the use of the type wrapper transparent.
- Generics add stability to your code by making more of you bugs detectable at compile time.
- A key point to understand about generic type is that a reference of one specific version of a generic type is not compatible with another version of the same generic type. So, generic types differ based on their type argument.
** A Generic Class with Two Type Parameters
- You can declare more than one type parameter in generic type. To specify two or more type parameters, simply use a comma-separated list.
  #+begin_src java
    class TwoGen<T, V>{
        ...
    }
  #+end_src
- The general form of a generic class is:
    class ClassName<type-param-list>{
        ...
    }
    // delcaring a reference to a generic class and instance creation
    ClassName<type-param-list> var-name = new ClassName<type-param-list>(cons-arg-list);
- to create generic interface, follow the same convention as for creating a generic class.
** Bounded Types
- The type parameters could be replaced by any class type. This is fine for many purposes, but sometimes it is useful to limit the types that can be passed to a type parameter. To handle those Java provides /bounded types/. When specifying a type parameter, you can create an upper bound that declares the superclass from which all type arguments must be derived. This accomplished through the use of *extends* clause when specifying the type parameter, as shown here:
      /<T *extends* superclass>/
      This specifies that /T/ can only be replaced by /superclass/ or subclass of /superclass/. Thus, /superclass/ defines an inclusive, upper limit.
- In addition to using a class type as a bound, you can also use an interface type. In fact, you can specify multiple interfaces. Furthermore, a bound can include both a class type and one or more interfaces, only type arguments that implement that interface are legal. When specifying a bound that has a class and an interface, or multiple interface, use the *&* operator to connect them.
      class Gen<T extends MyClass & MyInterface>{}
      Here, *T* is bounded by a class called *MyClass* and an interface *MyInterface*. Thus, any type argument passed to *T* must be subclass of *MyClass* and implements *MyInterface*
** Using Wildcard argument
- The wild card argument is specified by *?*, and it represents an unknown type. This wild card simply matches and /valid/ object.
- Wildcard arguments can be bounded in much the same way that a type parameter can be bounded. A bound wildcards is especially important when you are creating a generic type that will operate on a class hierarchy.
- In general, to establish an upper bound for a wildcard, use the following type of wildcard expression:
      <? extends /superclass/ >
      where /superclass/ is the name of the class that serves as the upper bound. Remember, this is an inclusive clause because the class forming the upper bound(that is, specified by /superclass/) is also within.
- You can also specify a lower bound for a wild by adding a *super* clause to a wild declaration. Here is its general declaration:
      <? super /subclass/ >
      In this case, only classes that are superclasses of /subclass/ are acceptable arguments. This is an inclusive clause.
** Creating A Generic Method
* Collections
